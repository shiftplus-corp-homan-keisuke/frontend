# Step 5: Context API„Éª„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ

## üìÖ Â≠¶ÁøíÊúüÈñì„ÉªÁõÆÊ®ô

**ÊúüÈñì**: Step 5
**Á∑èÂ≠¶ÁøíÊôÇÈñì**: 6 ÊôÇÈñì
**Â≠¶Áøí„Çπ„Çø„Ç§„É´**: ÁêÜË´ñ 20% + ÂÆüË∑µ„Ç≥„Éº„Éâ 50% + ÊºîÁøí 30%

### üéØ Step 5 Âà∞ÈÅîÁõÆÊ®ô

- [ ] Context API „ÅÆÂûãÂÆâÂÖ®„Å™ÂÆüË£Ö
- [ ] „Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ„ÅÆË®≠Ë®à„Éë„Çø„Éº„É≥
- [ ] Áä∂ÊÖã„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÊäΩË±°Âåñ
- [ ] Provider „Éë„Çø„Éº„É≥„ÅÆÊ¥ªÁî®
- [ ] „Ç∞„É≠„Éº„Éê„É´Áä∂ÊÖãÁÆ°ÁêÜ„ÅÆÂü∫Á§é

## üìö ÁêÜË´ñÂ≠¶ÁøíÂÜÖÂÆπ

### Day 29-31: Context API „ÅÆÂûãÂÆâÂÖ®„Å™ÂÆüË£Ö

#### üéØ Âü∫Êú¨ÁöÑ„Å™ Context ÂÆüË£Ö

```typescript
// 1. ÂûãÂÆâÂÖ®„Å™Context„ÅÆ‰ΩúÊàê
import React, {
  createContext,
  useContext,
  useState,
  useCallback,
  useMemo,
} from "react";

// Theme Context
interface ThemeContextType {
  theme: "light" | "dark";
  toggleTheme: () => void;
  colors: {
    primary: string;
    secondary: string;
    background: string;
    text: string;
  };
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// „Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ for Context
function useTheme(): ThemeContextType {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
}

// Provider „ÅÆÂÆüË£Ö
interface ThemeProviderProps {
  children: React.ReactNode;
  defaultTheme?: "light" | "dark";
}

function ThemeProvider({
  children,
  defaultTheme = "light",
}: ThemeProviderProps): JSX.Element {
  const [theme, setTheme] = useState<"light" | "dark">(defaultTheme);

  const toggleTheme = useCallback(() => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  }, []);

  const colors = useMemo(() => {
    return theme === "light"
      ? {
          primary: "#007bff",
          secondary: "#6c757d",
          background: "#ffffff",
          text: "#212529",
        }
      : {
          primary: "#0d6efd",
          secondary: "#6c757d",
          background: "#212529",
          text: "#ffffff",
        };
  }, [theme]);

  const value = useMemo<ThemeContextType>(
    () => ({
      theme,
      toggleTheme,
      colors,
    }),
    [theme, toggleTheme, colors]
  );

  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
}

// ‰ΩøÁî®‰æã
function App(): JSX.Element {
  return (
    <ThemeProvider defaultTheme="light">
      <Header />
      <MainContent />
    </ThemeProvider>
  );
}

function Header(): JSX.Element {
  const { theme, toggleTheme, colors } = useTheme();

  return (
    <header style={{ backgroundColor: colors.background, color: colors.text }}>
      <h1>My App</h1>
      <button onClick={toggleTheme}>
        Switch to {theme === "light" ? "dark" : "light"} mode
      </button>
    </header>
  );
}

// 2. Ë™çË®ºContext
interface User {
  id: string;
  name: string;
  email: string;
  role: "admin" | "user";
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  register: (userData: RegisterData) => Promise<void>;
  loading: boolean;
  error: string | null;
}

interface RegisterData {
  name: string;
  email: string;
  password: string;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}

function AuthProvider({
  children,
}: {
  children: React.ReactNode;
}): JSX.Element {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const login = useCallback(
    async (email: string, password: string): Promise<void> => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch("/api/auth/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ email, password }),
        });

        if (!response.ok) {
          throw new Error("Login failed");
        }

        const userData = (await response.json()) as User;
        setUser(userData);
      } catch (err) {
        setError(err instanceof Error ? err.message : "An error occurred");
      } finally {
        setLoading(false);
      }
    },
    []
  );

  const logout = useCallback(() => {
    setUser(null);
    setError(null);
  }, []);

  const register = useCallback(
    async (userData: RegisterData): Promise<void> => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch("/api/auth/register", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(userData),
        });

        if (!response.ok) {
          throw new Error("Registration failed");
        }

        const newUser = (await response.json()) as User;
        setUser(newUser);
      } catch (err) {
        setError(err instanceof Error ? err.message : "An error occurred");
      } finally {
        setLoading(false);
      }
    },
    []
  );

  const value = useMemo<AuthContextType>(
    () => ({
      user,
      login,
      logout,
      register,
      loading,
      error,
    }),
    [user, login, logout, register, loading, error]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// 3. Ë§áÊï∞Context„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ
function AppProviders({
  children,
}: {
  children: React.ReactNode;
}): JSX.Element {
  return (
    <ThemeProvider>
      <AuthProvider>
        <NotificationProvider>{children}</NotificationProvider>
      </AuthProvider>
    </ThemeProvider>
  );
}

// Ë§áÊï∞Context„Çí‰ΩøÁî®„Åô„Çã„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
function useAppContext() {
  const theme = useTheme();
  const auth = useAuth();
  const notifications = useNotifications();

  return {
    theme,
    auth,
    notifications,
  };
}
```

#### üîß È´òÂ∫¶„Å™ Context „Éë„Çø„Éº„É≥

```typescript
// 4. Reducer + Context „Éë„Çø„Éº„É≥
interface TodoState {
  todos: Todo[];
  filter: "all" | "active" | "completed";
  loading: boolean;
  error: string | null;
}

interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: Date;
}

type TodoAction =
  | { type: "ADD_TODO"; payload: { text: string } }
  | { type: "TOGGLE_TODO"; payload: { id: string } }
  | { type: "DELETE_TODO"; payload: { id: string } }
  | { type: "SET_FILTER"; payload: { filter: TodoState["filter"] } }
  | { type: "SET_LOADING"; payload: { loading: boolean } }
  | { type: "SET_ERROR"; payload: { error: string | null } };

function todoReducer(state: TodoState, action: TodoAction): TodoState {
  switch (action.type) {
    case "ADD_TODO":
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: crypto.randomUUID(),
            text: action.payload.text,
            completed: false,
            createdAt: new Date(),
          },
        ],
      };

    case "TOGGLE_TODO":
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
      };

    case "DELETE_TODO":
      return {
        ...state,
        todos: state.todos.filter((todo) => todo.id !== action.payload.id),
      };

    case "SET_FILTER":
      return {
        ...state,
        filter: action.payload.filter,
      };

    case "SET_LOADING":
      return {
        ...state,
        loading: action.payload.loading,
      };

    case "SET_ERROR":
      return {
        ...state,
        error: action.payload.error,
      };

    default:
      return state;
  }
}

interface TodoContextType {
  state: TodoState;
  dispatch: React.Dispatch<TodoAction>;
  addTodo: (text: string) => void;
  toggleTodo: (id: string) => void;
  deleteTodo: (id: string) => void;
  setFilter: (filter: TodoState["filter"]) => void;
  filteredTodos: Todo[];
}

const TodoContext = createContext<TodoContextType | undefined>(undefined);

function useTodos(): TodoContextType {
  const context = useContext(TodoContext);
  if (context === undefined) {
    throw new Error("useTodos must be used within a TodoProvider");
  }
  return context;
}

function TodoProvider({
  children,
}: {
  children: React.ReactNode;
}): JSX.Element {
  const [state, dispatch] = React.useReducer(todoReducer, {
    todos: [],
    filter: "all",
    loading: false,
    error: null,
  });

  const addTodo = useCallback((text: string) => {
    dispatch({ type: "ADD_TODO", payload: { text } });
  }, []);

  const toggleTodo = useCallback((id: string) => {
    dispatch({ type: "TOGGLE_TODO", payload: { id } });
  }, []);

  const deleteTodo = useCallback((id: string) => {
    dispatch({ type: "DELETE_TODO", payload: { id } });
  }, []);

  const setFilter = useCallback((filter: TodoState["filter"]) => {
    dispatch({ type: "SET_FILTER", payload: { filter } });
  }, []);

  const filteredTodos = useMemo(() => {
    switch (state.filter) {
      case "active":
        return state.todos.filter((todo) => !todo.completed);
      case "completed":
        return state.todos.filter((todo) => todo.completed);
      default:
        return state.todos;
    }
  }, [state.todos, state.filter]);

  const value = useMemo<TodoContextType>(
    () => ({
      state,
      dispatch,
      addTodo,
      toggleTodo,
      deleteTodo,
      setFilter,
      filteredTodos,
    }),
    [state, addTodo, toggleTodo, deleteTodo, setFilter, filteredTodos]
  );

  return <TodoContext.Provider value={value}>{children}</TodoContext.Provider>;
}
```

### Day 32-34: „Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ„ÅÆË®≠Ë®à„Éë„Çø„Éº„É≥

#### üéØ ÂÆüÁî®ÁöÑ„Å™„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ

```typescript
// 5. „Éá„Éº„Çø„Éï„Çß„ÉÉ„ÉÅ„É≥„Ç∞Áî®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
interface UseApiOptions<T> {
  enabled?: boolean;
  refetchInterval?: number;
  onSuccess?: (data: T) => void;
  onError?: (error: Error) => void;
  dependencies?: React.DependencyList;
}

interface UseApiResult<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
  mutate: (data: T) => void; // Ê•ΩË¶≥ÁöÑÊõ¥Êñ∞Áî®
}

function useApi<T>(
  fetcher: () => Promise<T>,
  options: UseApiOptions<T> = {}
): UseApiResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  const {
    enabled = true,
    refetchInterval,
    onSuccess,
    onError,
    dependencies = [],
  } = options;

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await fetcher();
      setData(result);
      onSuccess?.(result);
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Unknown error");
      setError(error);
      onError?.(error);
    } finally {
      setLoading(false);
    }
  }, [fetcher, onSuccess, onError]);

  const mutate = useCallback((newData: T) => {
    setData(newData);
  }, []);

  useEffect(() => {
    if (enabled) {
      void fetchData();
    }
  }, [enabled, fetchData, ...dependencies]);

  useEffect(() => {
    if (refetchInterval && enabled) {
      const interval = setInterval(() => {
        void fetchData();
      }, refetchInterval);

      return () => clearInterval(interval);
    }
  }, [refetchInterval, enabled, fetchData]);

  return {
    data,
    loading,
    error,
    refetch: fetchData,
    mutate,
  };
}

// ‰ΩøÁî®‰æã
function UserProfile({ userId }: { userId: string }): JSX.Element {
  const {
    data: user,
    loading,
    error,
    refetch,
  } = useApi<User>(
    () => fetch(`/api/users/${userId}`).then((res) => res.json()),
    {
      enabled: !!userId,
      onSuccess: (user) => console.log("User loaded:", user.name),
      dependencies: [userId],
    }
  );

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return <div>No user found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={() => void refetch()}>Refresh</button>
    </div>
  );
}

// 6. „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏Áî®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((prev: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? (JSON.parse(item) as T) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  const setValue = useCallback(
    (value: T | ((prev: T) => T)) => {
      try {
        const valueToStore =
          value instanceof Function ? value(storedValue) : value;
        setStoredValue(valueToStore);
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      } catch (error) {
        console.error(`Error setting localStorage key "${key}":`, error);
      }
    },
    [key, storedValue]
  );

  return [storedValue, setValue];
}

// 7. „Éá„Éê„Ç¶„É≥„ÇπÁî®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// 8. ÈùûÂêåÊúüÂá¶ÁêÜÁî®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
interface UseAsyncResult<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  execute: (...args: any[]) => Promise<void>;
  reset: () => void;
}

function useAsync<T>(
  asyncFunction: (...args: any[]) => Promise<T>
): UseAsyncResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = useCallback(
    async (...args: any[]) => {
      try {
        setLoading(true);
        setError(null);
        const result = await asyncFunction(...args);
        setData(result);
      } catch (err) {
        setError(err instanceof Error ? err : new Error("Unknown error"));
      } finally {
        setLoading(false);
      }
    },
    [asyncFunction]
  );

  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
  }, []);

  return {
    data,
    loading,
    error,
    execute,
    reset,
  };
}

// 9. „Ç§„É≥„Çø„Éº„Éê„É´Áî®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
function useInterval(callback: () => void, delay: number | null): void {
  const savedCallback = useRef<() => void>();

  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  useEffect(() => {
    function tick() {
      savedCallback.current?.();
    }

    if (delay !== null) {
      const id = setInterval(tick, delay);
      return () => clearInterval(id);
    }
  }, [delay]);
}

// 10. Ââç„ÅÆÂÄ§„ÇíË®òÊÜ∂„Åô„Çã„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T>();

  useEffect(() => {
    ref.current = value;
  });

  return ref.current;
}
```

### Day 35: Áä∂ÊÖã„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÊäΩË±°Âåñ

#### üéØ Ë§áÈõë„Å™Áä∂ÊÖãÁÆ°ÁêÜ„ÅÆÊäΩË±°Âåñ

```typescript
// 11. „Ç´„Ç¶„É≥„Çø„ÉºÁî®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
interface UseCounterOptions {
  min?: number;
  max?: number;
  step?: number;
}

interface UseCounterResult {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
  set: (value: number) => void;
}

function useCounter(
  initialValue: number = 0,
  options: UseCounterOptions = {}
): UseCounterResult {
  const { min, max, step = 1 } = options;
  const [count, setCount] = useState(initialValue);

  const increment = useCallback(() => {
    setCount((prev) => {
      const newValue = prev + step;
      return max !== undefined ? Math.min(newValue, max) : newValue;
    });
  }, [step, max]);

  const decrement = useCallback(() => {
    setCount((prev) => {
      const newValue = prev - step;
      return min !== undefined ? Math.max(newValue, min) : newValue;
    });
  }, [step, min]);

  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);

  const set = useCallback((value: number) => {
    setCount(value);
  }, []);

  return {
    count,
    increment,
    decrement,
    reset,
    set,
  };
}

// 12. „Éà„Ç∞„É´Áî®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
function useToggle(
  initialValue: boolean = false
): [boolean, () => void, (value: boolean) => void] {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue((prev) => !prev);
  }, []);

  const set = useCallback((newValue: boolean) => {
    setValue(newValue);
  }, []);

  return [value, toggle, set];
}

// 13. ÈÖçÂàóÊìç‰ΩúÁî®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ
interface UseArrayResult<T> {
  array: T[];
  set: (array: T[]) => void;
  push: (item: T) => void;
  filter: (callback: (item: T) => boolean) => void;
  update: (index: number, item: T) => void;
  remove: (index: number) => void;
  clear: () => void;
}

function useArray<T>(initialArray: T[] = []): UseArrayResult<T> {
  const [array, setArray] = useState<T[]>(initialArray);

  const push = useCallback((item: T) => {
    setArray((prev) => [...prev, item]);
  }, []);

  const filter = useCallback((callback: (item: T) => boolean) => {
    setArray((prev) => prev.filter(callback));
  }, []);

  const update = useCallback((index: number, item: T) => {
    setArray((prev) =>
      prev.map((prevItem, i) => (i === index ? item : prevItem))
    );
  }, []);

  const remove = useCallback((index: number) => {
    setArray((prev) => prev.filter((_, i) => i !== index));
  }, []);

  const clear = useCallback(() => {
    setArray([]);
  }, []);

  const set = useCallback((newArray: T[]) => {
    setArray(newArray);
  }, []);

  return {
    array,
    set,
    push,
    filter,
    update,
    remove,
    clear,
  };
}
```

## üéØ ÂÆüË∑µÊºîÁøí

### ÊºîÁøí 5-1: Context „Ç∑„Çπ„ÉÜ„É†ÊßãÁØâ üî∞

```typescript
// ‰ª•‰∏ã„ÅÆË¶Å‰ª∂„ÇíÊ∫Ä„Åü„ÅôContext „Ç∑„Çπ„ÉÜ„É†„ÇíÂÆüË£Ö„Åõ„Çà

// 1. „Ç∑„Éß„ÉÉ„Éî„É≥„Ç∞„Ç´„Éº„Éà Context
interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
  image: string;
}

interface CartContextType {
  items: CartItem[];
  totalItems: number;
  totalPrice: number;
  addItem: (product: Product, quantity?: number) => void;
  removeItem: (productId: string) => void;
  updateQuantity: (productId: string, quantity: number) => void;
  clearCart: () => void;
}

// Ë¶Å‰ª∂:
// - ÂûãÂÆâÂÖ®„Å™„Ç´„Éº„ÉàÊìç‰Ωú
// - Ëá™ÂãïË®àÁÆóÔºàÂêàË®àÈáëÈ°ç„ÉªÂÄãÊï∞Ôºâ
// - „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏ÂêåÊúü
// - Ê•ΩË¶≥ÁöÑÊõ¥Êñ∞

// 2. ÈÄöÁü•„Ç∑„Çπ„ÉÜ„É† Context
interface Notification {
  id: string;
  type: "success" | "error" | "warning" | "info";
  title: string;
  message: string;
  duration?: number;
  action?: {
    label: string;
    onClick: () => void;
  };
}

interface NotificationContextType {
  notifications: Notification[];
  addNotification: (notification: Omit<Notification, "id">) => void;
  removeNotification: (id: string) => void;
  clearAll: () => void;
}

// Ë¶Å‰ª∂:
// - Ëá™ÂãïÂâäÈô§Ê©üËÉΩ
// - „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂØæÂøú
// - ÊúÄÂ§ßË°®Á§∫Êï∞Âà∂Èôê
// - „Ç¢„ÇØ„Ç∑„Éß„É≥‰ªò„ÅçÈÄöÁü•
```

### ÊºîÁøí 5-2: „Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ„É©„Ç§„Éñ„É©„É™ üî∂

```typescript
// ‰ª•‰∏ã„ÅÆË¶Å‰ª∂„ÇíÊ∫Ä„Åü„Åô„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ„É©„Ç§„Éñ„É©„É™„ÇíÂÆüË£Ö„Åõ„Çà

// 1. useInfiniteScroll
interface UseInfiniteScrollOptions {
  threshold?: number;
  hasMore: boolean;
  loading: boolean;
}

interface UseInfiniteScrollResult {
  ref: React.RefObject<HTMLDivElement>;
  loadMore: () => void;
}

function useInfiniteScroll(
  onLoadMore: () => void,
  options: UseInfiniteScrollOptions
): UseInfiniteScrollResult;

// 2. useClickOutside
function useClickOutside<T extends HTMLElement>(
  handler: () => void
): React.RefObject<T>;

// 3. useMediaQuery
function useMediaQuery(query: string): boolean;

// 4. useKeyPress
function useKeyPress(
  targetKey: string,
  handler: () => void,
  options?: { preventDefault?: boolean }
): void;

// Ë¶Å‰ª∂:
// - ÂÆåÂÖ®„Å™ÂûãÂÆâÂÖ®ÊÄß
// - „É°„É¢„É™„É™„Éº„ÇØÈò≤Ê≠¢
// - „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ
// - ÂÜçÂà©Áî®ÊÄß„ÅÆÁ¢∫‰øù
```

### ÊºîÁøí 5-3: ÂÆüÁî®ÁöÑ„Å™Áä∂ÊÖãÁÆ°ÁêÜ„Ç¢„Éó„É™ üî•

```typescript
// ‰ª•‰∏ã„ÅÆË¶Å‰ª∂„ÇíÊ∫Ä„Åü„Åô„Éñ„É≠„Ç∞ÁÆ°ÁêÜ„Ç¢„Éó„É™„ÇíÂÆüË£Ö„Åõ„Çà

interface BlogPost {
  id: string;
  title: string;
  content: string;
  excerpt: string;
  author: User;
  tags: string[];
  publishedAt?: Date;
  updatedAt: Date;
  status: "draft" | "published" | "archived";
}

interface BlogContextType {
  posts: BlogPost[];
  currentPost: BlogPost | null;
  loading: boolean;
  error: string | null;

  // CRUDÊìç‰Ωú
  createPost: (post: Omit<BlogPost, "id" | "updatedAt">) => Promise<void>;
  updatePost: (id: string, updates: Partial<BlogPost>) => Promise<void>;
  deletePost: (id: string) => Promise<void>;
  publishPost: (id: string) => Promise<void>;

  // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞„ÉªÊ§úÁ¥¢
  searchPosts: (query: string) => void;
  filterByTag: (tag: string) => void;
  filterByStatus: (status: BlogPost["status"]) => void;

  // „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥
  loadMore: () => Promise<void>;
  hasMore: boolean;
}

// Ë¶Å‰ª∂:
// - „É™„Ç¢„É´„Çø„Ç§„É†Êõ¥Êñ∞
// - Ê•ΩË¶≥ÁöÑÊõ¥Êñ∞
// - „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
// - „Ç≠„É£„ÉÉ„Ç∑„É•ÁÆ°ÁêÜ
// - Ê§úÁ¥¢„Éª„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
// - ÁÑ°Èôê„Çπ„ÇØ„É≠„Éº„É´
// - Ëá™Âãï‰øùÂ≠òÊ©üËÉΩ
```

## üìä Step 5 Ë©ï‰æ°Âü∫Ê∫ñ

### ÁêÜËß£Â∫¶„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà

#### Context API (35%)

- [ ] ÂûãÂÆâÂÖ®„Å™ Context „Çí‰ΩúÊàê„Åß„Åç„Çã
- [ ] Provider „Éë„Çø„Éº„É≥„ÇíÈÅ©Âàá„Å´ÂÆüË£Ö„Åß„Åç„Çã
- [ ] Ë§áÊï∞ Context „ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„Åå„Åß„Åç„Çã
- [ ] „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÇíËÄÉÊÖÆ„Åó„ÅüÂÆüË£Ö„Åå„Åß„Åç„Çã

#### „Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ (40%)

- [ ] ÂÜçÂà©Áî®ÂèØËÉΩ„Å™„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ„ÇíË®≠Ë®à„Åß„Åç„Çã
- [ ] Ë§áÈõë„Å™Áä∂ÊÖã„É≠„Ç∏„ÉÉ„ÇØ„ÇíÊäΩË±°Âåñ„Åß„Åç„Çã
- [ ] ÂâØ‰ΩúÁî®„ÇíÈÅ©Âàá„Å´ÁÆ°ÁêÜ„Åß„Åç„Çã
- [ ] ÂûãÂÆâÂÖ®„Å™ API „ÇíÊèê‰æõ„Åß„Åç„Çã

#### Áä∂ÊÖãÁÆ°ÁêÜË®≠Ë®à (20%)

- [ ] ÈÅ©Âàá„Å™Áä∂ÊÖãÁÆ°ÁêÜ„Éë„Çø„Éº„É≥„ÇíÈÅ∏Êäû„Åß„Åç„Çã
- [ ] „Ç∞„É≠„Éº„Éê„É´Áä∂ÊÖã„Å®„É≠„Éº„Ç´„É´Áä∂ÊÖã„Çí‰Ωø„ÅÑÂàÜ„Åë„Åß„Åç„Çã
- [ ] Áä∂ÊÖã„ÅÆÊ≠£Ë¶èÂåñ„Åå„Åß„Åç„Çã
- [ ] „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ„ÇíÂÆüË£Ö„Åß„Åç„Çã

#### ÂÆüË∑µÂøúÁî® (5%)

- [ ] ÂÆüÁî®ÁöÑ„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíË®≠Ë®à„Åß„Åç„Çã
- [ ] ‰øùÂÆàÊÄß„ÅÆÈ´ò„ÅÑ„Ç≥„Éº„ÉâË®≠Ë®à„Åå„Åß„Åç„Çã
- [ ] „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÇíÈÅ©Âàá„Å´Ë°å„Åà„Çã
- [ ] „ÉÜ„Çπ„Çø„Éñ„É´„Å™„Ç≥„Éº„Éâ„ÇíÊõ∏„Åë„Çã

### ÊàêÊûúÁâ©„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà

- [ ] **Context „Ç∑„Çπ„ÉÜ„É†**: „ÉÜ„Éº„Éû„ÉªË™çË®º„ÉªÈÄöÁü•Á≠â„ÅÆÁµ±Âêà„Ç∑„Çπ„ÉÜ„É†
- [ ] **„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ„É©„Ç§„Éñ„É©„É™**: 10 ÂÄã‰ª•‰∏ä„ÅÆÂÜçÂà©Áî®ÂèØËÉΩ„Éï„ÉÉ„ÇØ
- [ ] **Áä∂ÊÖãÁÆ°ÁêÜ„Ç¢„Éó„É™**: „Éñ„É≠„Ç∞ÁÆ°ÁêÜÁ≠â„ÅÆÂÆüÁî®ÁöÑ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥
- [ ] **„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ**: „É°„É¢Âåñ„Å®„É¨„É≥„ÉÄ„É™„É≥„Ç∞ÊúÄÈÅ©Âåñ

## üîÑ Step 6 „Å∏„ÅÆÊ∫ñÂÇô

### Ê¨°ÈÄ±Â≠¶ÁøíÂÜÖÂÆπ„ÅÆ‰∫àÁøí

```typescript
// Step 6„ÅßÂ≠¶Áøí„Åô„ÇãÁä∂ÊÖãÁÆ°ÁêÜ„É©„Ç§„Éñ„É©„É™„ÅÆÂü∫Á§éÊ¶ÇÂøµ

// 1. Zustand „ÅÆÂü∫Êú¨
import { create } from "zustand";

interface CounterStore {
  count: number;
  increment: () => void;
  decrement: () => void;
}

const useCounterStore = create<CounterStore>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

// 2. TanStack Query „ÅÆÂü∫Êú¨
import { useQuery, useMutation } from "@tanstack/react-query";

function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
  });
}
```

---

**üìå ÈáçË¶Å**: Step 5 „ÅØ React „ÅÆÁä∂ÊÖãÁÆ°ÁêÜ„ÇíÂÆåÂÖ®„Å´ÁêÜËß£„Åó„ÄÅÂÆüË∑µÁöÑ„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÈñãÁô∫„ÅÆÂü∫Áõ§„ÇíÁØâ„ÅèÈáçË¶Å„Å™ÊúüÈñì„Åß„Åô„ÄÇContext API „Å®„Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ„ÅÆÁøíÂæó„Å´„Çà„Çä„ÄÅÂæå„ÅÆÈ´òÂ∫¶„Å™Áä∂ÊÖãÁÆ°ÁêÜ„É©„Ç§„Éñ„É©„É™Â≠¶Áøí„Åå„Çπ„É†„Éº„Ç∫„Å´ÈÄ≤„Åø„Åæ„Åô„ÄÇ
