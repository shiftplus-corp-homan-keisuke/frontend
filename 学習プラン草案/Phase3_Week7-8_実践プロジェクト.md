# Phase 3: Week 7-8 å®Ÿè·µãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ - ãƒ–ãƒ­ã‚°ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å®Œå…¨å®Ÿè£…

## ğŸ“… å­¦ç¿’æœŸé–“ãƒ»ç›®æ¨™

**æœŸé–“**: Week 7-8ï¼ˆ2 é€±é–“ï¼‰  
**ç·å­¦ç¿’æ™‚é–“**: 40 æ™‚é–“ï¼ˆé€± 10 æ™‚é–“ï¼‰

### ğŸ¯ Week 7-8 åˆ°é”ç›®æ¨™

- [ ] è¤‡é›‘ãªãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã®å®Ÿè·µ
- [ ] ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°ãƒ»CQRS ã®å®Œå…¨å®Ÿè£…
- [ ] ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã®é©ç”¨
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¨ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°å¯¾å¿œ
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆãƒ»E2E ãƒ†ã‚¹ãƒˆã®å®Ÿè£…
- [ ] æœ¬æ ¼çš„ãªãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³å“è³ªã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰

## ğŸ“– æœ€çµ‚ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: ãƒ–ãƒ­ã‚°ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 

### ğŸ¯ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

**ã‚·ã‚¹ãƒ†ãƒ å**: TypeScript Blog Platform  
**ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: Event-Driven Microservices with CQRS  
**æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯**: TypeScript, Node.js, PostgreSQL, Redis, Docker

### ğŸ“‹ æ©Ÿèƒ½è¦ä»¶

#### 1. è¨˜äº‹ç®¡ç†æ©Ÿèƒ½

- è¨˜äº‹ã®ä½œæˆãƒ»ç·¨é›†ãƒ»å…¬é–‹ãƒ»ä¸‹æ›¸ãä¿å­˜
- ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å¯¾å¿œ
- ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ»ç®¡ç†
- ã‚¿ã‚°ãƒ»ã‚«ãƒ†ã‚´ãƒªç®¡ç†
- SEO æœ€é©åŒ–ï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç®¡ç†ï¼‰

#### 2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†æ©Ÿèƒ½

- è‘—è€…ç™»éŒ²ãƒ»èªè¨¼ãƒ»èªå¯
- ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç®¡ç†
- ãƒ­ãƒ¼ãƒ«ç®¡ç†ï¼ˆç®¡ç†è€…ãƒ»ç·¨é›†è€…ãƒ»è‘—è€…ãƒ»èª­è€…ï¼‰
- ãƒ•ã‚©ãƒ­ãƒ¼ãƒ»ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ©Ÿèƒ½

#### 3. ã‚³ãƒ¡ãƒ³ãƒˆãƒ»ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½

- ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿ãƒ»è¿”ä¿¡
- ã„ã„ã­ãƒ»ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯
- è¨˜äº‹å…±æœ‰æ©Ÿèƒ½
- é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

#### 4. æ¤œç´¢ãƒ»ç™ºè¦‹æ©Ÿèƒ½

- å…¨æ–‡æ¤œç´¢
- ã‚¿ã‚°ãƒ»ã‚«ãƒ†ã‚´ãƒªæ¤œç´¢
- äººæ°—è¨˜äº‹ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰è¡¨ç¤º
- ãƒ¬ã‚³ãƒ¡ãƒ³ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

## ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹æ§‹æˆ

```mermaid
graph TD
    A[API Gateway] --> B[User Service]
    A --> C[Blog Service]
    A --> D[Comment Service]
    A --> E[Search Service]
    A --> F[Notification Service]

    B --> G[User DB]
    C --> H[Blog DB]
    D --> I[Comment DB]
    E --> J[Elasticsearch]
    F --> K[Redis]

    L[Event Bus] --> B
    L --> C
    L --> D
    L --> E
    L --> F

    M[Event Store] --> L

    style A fill:#ff9999
    style L fill:#99ccff
    style M fill:#99ffcc
```

### CQRS + Event Sourcing ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```typescript
// Event Sourcing åŸºç›¤
interface DomainEvent {
  eventId: string;
  aggregateId: string;
  aggregateType: string;
  eventType: string;
  eventData: any;
  eventVersion: number;
  occurredAt: Date;
  causationId?: string;
  correlationId?: string;
}

interface EventStore {
  saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion: number
  ): Promise<Result<void, EventStoreError>>;

  getEvents(
    aggregateId: string,
    fromVersion?: number
  ): Promise<Result<DomainEvent[], EventStoreError>>;

  getAllEvents(
    fromPosition?: number,
    maxCount?: number
  ): Promise<Result<DomainEvent[], EventStoreError>>;
}

// Event Store å®Ÿè£…
class PostgresEventStore implements EventStore {
  constructor(private db: DatabaseConnection) {}

  async saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion: number
  ): Promise<Result<void, EventStoreError>> {
    try {
      await this.db.transaction(async (trx) => {
        // æ¥½è¦³çš„ãƒ­ãƒƒã‚¯
        const currentVersion = await this.getCurrentVersion(aggregateId, trx);
        if (currentVersion !== expectedVersion) {
          throw new ConcurrencyError(
            `Expected version ${expectedVersion}, but current version is ${currentVersion}`
          );
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆä¿å­˜
        for (const event of events) {
          await trx("events").insert({
            event_id: event.eventId,
            aggregate_id: event.aggregateId,
            aggregate_type: event.aggregateType,
            event_type: event.eventType,
            event_data: JSON.stringify(event.eventData),
            event_version: event.eventVersion,
            occurred_at: event.occurredAt,
            causation_id: event.causationId,
            correlation_id: event.correlationId,
          });
        }
      });

      return Result.ok(undefined);
    } catch (error) {
      return Result.err(
        new EventStoreError(`Failed to save events: ${error.message}`)
      );
    }
  }

  async getEvents(
    aggregateId: string,
    fromVersion: number = 0
  ): Promise<Result<DomainEvent[], EventStoreError>> {
    try {
      const rows = await this.db("events")
        .where("aggregate_id", aggregateId)
        .where("event_version", ">", fromVersion)
        .orderBy("event_version", "asc");

      const events = rows.map((row) => ({
        eventId: row.event_id,
        aggregateId: row.aggregate_id,
        aggregateType: row.aggregate_type,
        eventType: row.event_type,
        eventData: JSON.parse(row.event_data),
        eventVersion: row.event_version,
        occurredAt: row.occurred_at,
        causationId: row.causation_id,
        correlationId: row.correlation_id,
      }));

      return Result.ok(events);
    } catch (error) {
      return Result.err(
        new EventStoreError(`Failed to get events: ${error.message}`)
      );
    }
  }

  private async getCurrentVersion(
    aggregateId: string,
    trx: any
  ): Promise<number> {
    const result = await trx("events")
      .where("aggregate_id", aggregateId)
      .max("event_version as max_version")
      .first();

    return result?.max_version || 0;
  }
}
```

## ğŸ“ ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«å®Ÿè£…

### Blog Aggregate

````typescript
// Blog Post Events
interface BlogPostCreatedEvent extends DomainEvent {
  eventType: 'BlogPostCreated';
  eventData: {
    title: string;
    content: string;
    authorId: string;
    tags: string[];
    category: string;
  };
}

interface BlogPostPublishedEvent extends DomainEvent {
  eventType: 'BlogPostPublished';
  eventData: {
    publishedAt: Date;
    slug: string;
  };
}

interface BlogPostContentUpdatedEvent extends DomainEvent {
  eventType: 'BlogPostContentUpdated';
  eventData: {
    title: string;
    content: string;
    updatedAt: Date;
  };
}

// Blog Post Aggregate
class BlogPost extends EventSourcedAggregateRoot {
  private _id: BlogPostId;
  private _title: string;
  private _content: string;
  private _authorId: UserId;
  private _status: BlogPostStatus;
  private _tags: string[];
  private _category: string;
  private _slug?: string;
  private _publishedAt?: Date;
  private _createdAt: Date;
  private _updatedAt: Date;

  private constructor() {
    super();
  }

  static create(
    title: string,
    content: string,
    authorId: UserId,
    tags: string[],
    category: string
  ): Result<BlogPost, BlogPostError> {
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!title.trim()) {
      return Result.err(new BlogPostError('Title cannot be empty'));
    }
    if (!content.trim()) {
      return Result.err(new BlogPostError('Content cannot be empty'));
    }
    if (tags.length === 0) {
      return Result.err(new BlogPostError('At least one tag is required'));
    }

    const blogPost = new BlogPost();
    const event: BlogPostCreatedEvent = {
      eventId: crypto.randomUUID(),
      aggregateId: BlogPostId.generate().toString(),
      aggregateType: 'BlogPost',
      eventType: 'BlogPostCreated',
      eventData: {
        title,
        content,
        authorId: authorId.toString(),
        tags,
        category
      },
      eventVersion: 1,
      occurredAt: new Date()
    };

    blogPost.addEvent(event);
    return Result.ok(blogPost);
  }

  publish(): Result<void, BlogPostError> {
    if (this._status === BlogPostStatus.Published) {
      return Result.err(new BlogPostError('Blog post is already published'));
    }

    const slug = this.generateSlug(this._title);
    const event: BlogPostPublishedEvent = {
      eventId: crypto.randomUUID(),
      aggregateId: this._id.toString(),
      aggregateType: 'BlogPost',
      eventType: 'BlogPostPublished',
      eventData: {
        publishedAt: new Date(),
        slug
      },
      eventVersion: this.version + 1,
      occurredAt: new Date()
    };

    this.addEvent(event);
    return Result.ok(undefined);
  }

  updateContent(title: string, content: string): Result<void, BlogPostError> {
    if (this._status === BlogPostStatus.Published) {
      return Result.err(new BlogPostError('Cannot update published blog post'));
    }

    if (!title.trim() || !content.trim()) {
      return Result.err(new BlogPostError('Title and content cannot be empty'));
    }

### Comment Aggregate

```typescript
// Comment Events
interface CommentAddedEvent extends DomainEvent {
  eventType: 'CommentAdded';
  eventData: {
    blogPostId: string;
    authorId: string;
    content: string;
    parentCommentId?: string;
  };
}

interface CommentApprovedEvent extends DomainEvent {
  eventType: 'CommentApproved';
  eventData: {
    approvedBy: string;
    approvedAt: Date;
  };
}

// Comment Aggregate
class Comment extends EventSourcedAggregateRoot {
  private _id: CommentId;
  private _blogPostId: BlogPostId;
  private _authorId: UserId;
  private _content: string;
  private _status: CommentStatus;
  private _parentCommentId?: CommentId;
  private _createdAt: Date;
  private _approvedAt?: Date;
  private _approvedBy?: UserId;

  private constructor() {
    super();
  }

  static create(
    blogPostId: BlogPostId,
    authorId: UserId,
    content: string,
    parentCommentId?: CommentId
  ): Result<Comment, CommentError> {
    if (!content.trim()) {
      return Result.err(new CommentError('Comment content cannot be empty'));
    }
    if (content.length > 1000) {
      return Result.err(new CommentError('Comment content too long'));
    }

    const comment = new Comment();
    const event: CommentAddedEvent = {
      eventId: crypto.randomUUID(),
      aggregateId: CommentId.generate().toString(),
      aggregateType: 'Comment',
      eventType: 'CommentAdded',
      eventData: {
        blogPostId: blogPostId.toString(),
        authorId: authorId.toString(),
        content,
        parentCommentId: parentCommentId?.toString()
      },
      eventVersion: 1,
      occurredAt: new Date()
    };

    comment.addEvent(event);
    return Result.ok(comment);
  }

  approve(approvedBy: UserId): Result<void, CommentError> {
    if (this._status === CommentStatus.Approved) {
      return Result.err(new CommentError('Comment is already approved'));
    }

    const event: CommentApprovedEvent = {
      eventId: crypto.randomUUID(),
      aggregateId: this._id.toString(),
      aggregateType: 'Comment',
      eventType: 'CommentApproved',
      eventData: {
        approvedBy: approvedBy.toString(),
        approvedAt: new Date()
      },
      eventVersion: this.version + 1,
      occurredAt: new Date()
    };

    this.addEvent(event);
    return Result.ok(undefined);
  }

  apply(event: DomainEvent): void {
    switch (event.eventType) {
      case 'CommentAdded':
        this.applyCommentAdded(event as CommentAddedEvent);
        break;
      case 'CommentApproved':
        this.applyCommentApproved(event as CommentApprovedEvent);
        break;
    }
    this.version = event.eventVersion;
  }

  private applyCommentAdded(event: CommentAddedEvent): void {
    this._id = CommentId.create(event.aggregateId);
    this._blogPostId = BlogPostId.create(event.eventData.blogPostId);
    this._authorId = UserId.create(event.eventData.authorId);
    this._content = event.eventData.content;
    this._status = CommentStatus.Pending;
    this._parentCommentId = event.eventData.parentCommentId
      ? CommentId.create(event.eventData.parentCommentId)
      : undefined;
    this._createdAt = event.occurredAt;
  }

  private applyCommentApproved(event: CommentApprovedEvent): void {
    this._status = CommentStatus.Approved;
    this._approvedBy = UserId.create(event.eventData.approvedBy);
    this._approvedAt = event.eventData.approvedAt;
  }

  // Getters
  get id(): CommentId { return this._id; }
  get blogPostId(): BlogPostId { return this._blogPostId; }
  get authorId(): UserId { return this._authorId; }
  get content(): string { return this._content; }
  get status(): CommentStatus { return this._status; }
  get parentCommentId(): CommentId | undefined { return this._parentCommentId; }
  get createdAt(): Date { return this._createdAt; }
  get approvedAt(): Date | undefined { return this._approvedAt; }
  get approvedBy(): UserId | undefined { return this._approvedBy; }
}

enum CommentStatus {
  Pending = 'pending',
  Approved = 'approved',
  Rejected = 'rejected'
}

class CommentError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CommentError';
  }
}
````

## ğŸ”„ CQRS å®Ÿè£…

### Command Side

```typescript
// Commands
interface CreateBlogPostCommand {
  commandId: string;
  title: string;
  content: string;
  authorId: string;
  tags: string[];
  category: string;
}

interface PublishBlogPostCommand {
  commandId: string;
  blogPostId: string;
  publisherId: string;
}

// Command Handlers
class CreateBlogPostCommandHandler
  implements CommandHandler<CreateBlogPostCommand>
{
  constructor(
    private blogPostRepository: EventSourcedRepository<BlogPost>,
    private eventBus: EventBus,
    private logger: Logger
  ) {}

  async handle(
    command: CreateBlogPostCommand
  ): Promise<Result<void, CommandError>> {
    try {
      const authorId = UserId.create(command.authorId);

      const blogPostResult = BlogPost.create(
        command.title,
        command.content,
        authorId,
        command.tags,
        command.category
      );

      if (blogPostResult.isErr()) {
        return Result.err(new CommandError(blogPostResult.error.message));
      }

      const saveResult = await this.blogPostRepository.save(
        blogPostResult.value
      );
      if (saveResult.isErr()) {
        return Result.err(
          new CommandError(
            `Failed to save blog post: ${saveResult.error.message}`
          )
        );
      }

      // ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
      const events = blogPostResult.value.getUncommittedEvents();
      for (const event of events) {
        await this.eventBus.publish(event);
      }

      this.logger.info("Blog post created successfully", {
        commandId: command.commandId,
        blogPostId: blogPostResult.value.id.toString(),
      });

      return Result.ok(undefined);
    } catch (error) {
      this.logger.error("Error handling CreateBlogPostCommand", error);
      return Result.err(new CommandError("An unexpected error occurred"));
    }
  }
}
```

### Query Side

```typescript
// Read Models (Projections)
interface BlogPostProjection {
  id: string;
  title: string;
  content: string;
  excerpt: string;
  authorId: string;
  authorName: string;
  authorAvatar: string;
  status: string;
  tags: string[];
  category: string;
  slug: string;
  publishedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
  commentCount: number;
  likeCount: number;
  viewCount: number;
}

// Queries
interface GetBlogPostQuery {
  queryId: string;
  blogPostId: string;
}

interface GetBlogPostsQuery {
  queryId: string;
  authorId?: string;
  category?: string;
  tags?: string[];
  status?: string;
  page: number;
  pageSize: number;
  sortBy: "createdAt" | "publishedAt" | "viewCount" | "likeCount";
  sortOrder: "asc" | "desc";
}

// Query Handlers
class GetBlogPostQueryHandler
  implements QueryHandler<GetBlogPostQuery, BlogPostProjection>
{
  constructor(
    private blogPostReadRepository: BlogPostReadRepository,
    private logger: Logger
  ) {}

  async handle(
    query: GetBlogPostQuery
  ): Promise<Result<BlogPostProjection, QueryError>> {
    try {
      const blogPost = await this.blogPostReadRepository.findById(
        query.blogPostId
      );

      if (!blogPost) {
        return Result.err(
          new QueryError(`Blog post not found: ${query.blogPostId}`)
        );
      }

      return Result.ok(blogPost);
    } catch (error) {
      this.logger.error("Error handling GetBlogPostQuery", error);
      return Result.err(new QueryError("An unexpected error occurred"));
    }
  }
}
```

## ğŸ¯ å®Ÿè·µæ¼”ç¿’

### æ¼”ç¿’ 7-1: ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°å®Œå…¨å®Ÿè£… ğŸ”¥

**ç›®æ¨™**: Event Sourcing + CQRS ã®å®Œå…¨ãªå®Ÿè£…

```typescript
// ä»¥ä¸‹ã®è¦ä»¶ã‚’æº€ãŸã™ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã›ã‚ˆ

// è¦ä»¶:
// 1. User Aggregate ã® Event Sourcing å®Ÿè£…
// 2. ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢ã®æ¥½è¦³çš„ãƒ­ãƒƒã‚¯
// 3. ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ©Ÿèƒ½
// 4. ã‚¤ãƒ™ãƒ³ãƒˆãƒªãƒ—ãƒ¬ã‚¤æ©Ÿèƒ½
// 5. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°ã®å†ªç­‰æ€§

// User Events
interface UserRegisteredEvent extends DomainEvent {
  eventType: "UserRegistered";
  eventData: {
    email: string;
    name: string;
    hashedPassword: string;
  };
}

interface UserProfileUpdatedEvent extends DomainEvent {
  eventType: "UserProfileUpdated";
  eventData: {
    name: string;
    bio: string;
    avatar: string;
  };
}

interface UserFollowedEvent extends DomainEvent {
  eventType: "UserFollowed";
  eventData: {
    followerId: string;
    followedId: string;
  };
}

// User Aggregate
class User extends EventSourcedAggregateRoot {
  private _id: UserId;
  private _email: Email;
  private _name: string;
  private _hashedPassword: string;
  private _bio: string;
  private _avatar: string;
  private _followers: Set<UserId>;
  private _following: Set<UserId>;
  private _createdAt: Date;
  private _updatedAt: Date;

  // å®Ÿè£…è¦ä»¶:
  // - å…¨ã¦ã®ã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾ã™ã‚‹applyãƒ¡ã‚½ãƒƒãƒ‰
  // - ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®æ¤œè¨¼
  // - ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆä½œæˆãƒ»å¾©å…ƒ
  // - ã‚¤ãƒ™ãƒ³ãƒˆãƒªãƒ—ãƒ¬ã‚¤æ©Ÿèƒ½
}

// ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ©Ÿèƒ½
interface Snapshot {
  aggregateId: string;
  aggregateType: string;
  data: any;
  version: number;
  createdAt: Date;
}

interface SnapshotStore {
  saveSnapshot(snapshot: Snapshot): Promise<Result<void, SnapshotError>>;
  getSnapshot(
    aggregateId: string
  ): Promise<Result<Maybe<Snapshot>, SnapshotError>>;
}

// ã‚¤ãƒ™ãƒ³ãƒˆãƒªãƒ—ãƒ¬ã‚¤æ©Ÿèƒ½
class EventReplayService {
  constructor(
    private eventStore: EventStore,
    private snapshotStore: SnapshotStore
  ) {}

  async replayEvents<T extends EventSourcedAggregateRoot>(
    aggregateId: string,
    aggregateType: new () => T
  ): Promise<Result<T, ReplayError>> {
    // å®Ÿè£…è¦ä»¶:
    // 1. ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‹ã‚‰å¾©å…ƒ
    // 2. ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆä»¥é™ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’é©ç”¨
    // 3. ç¾åœ¨ã®çŠ¶æ…‹ã‚’å†æ§‹ç¯‰
  }
}
```

### æ¼”ç¿’ 7-2: ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹çµ±åˆãƒ†ã‚¹ãƒˆ ğŸ”¶

**ç›®æ¨™**: ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–“ã®çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè£…

```typescript
// ä»¥ä¸‹ã®çµ±åˆãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ªã‚’å®Ÿè£…ã›ã‚ˆ

// ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª:
// 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ² â†’ ãƒ–ãƒ­ã‚°æŠ•ç¨¿ä½œæˆ â†’ ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ  â†’ é€šçŸ¥é€ä¿¡
// 2. è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹é–“ã®ã‚¤ãƒ™ãƒ³ãƒˆé€£æºãƒ†ã‚¹ãƒˆ
// 3. éšœå®³æ™‚ã®å¾©æ—§ãƒ†ã‚¹ãƒˆ
// 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

describe("Blog Platform Integration Tests", () => {
  let testContainer: TestContainer;
  let userService: UserService;
  let blogService: BlogService;
  let commentService: CommentService;
  let notificationService: NotificationService;

  beforeEach(async () => {
    testContainer = await TestContainer.create();
    // ã‚µãƒ¼ãƒ“ã‚¹åˆæœŸåŒ–
  });

  it("should handle complete blog workflow", async () => {
    // 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
    const userResult = await userService.registerUser({
      email: "test@example.com",
      name: "Test User",
      password: "password123",
    });
    expect(userResult.isOk()).toBe(true);

    // 2. ãƒ–ãƒ­ã‚°æŠ•ç¨¿ä½œæˆ
    const blogPostResult = await blogService.createBlogPost({
      title: "Test Post",
      content: "Test content",
      authorId: userResult.value.id,
      tags: ["test"],
      category: "technology",
    });
    expect(blogPostResult.isOk()).toBe(true);

    // 3. ãƒ–ãƒ­ã‚°æŠ•ç¨¿å…¬é–‹
    const publishResult = await blogService.publishBlogPost({
      blogPostId: blogPostResult.value.id,
      publisherId: userResult.value.id,
    });
    expect(publishResult.isOk()).toBe(true);

    // 4. ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ 
    const commentResult = await commentService.addComment({
      blogPostId: blogPostResult.value.id,
      authorId: userResult.value.id,
      content: "Great post!",
    });
    expect(commentResult.isOk()).toBe(true);

    // 5. é€šçŸ¥ç¢ºèª
    await waitForEventProcessing();
    const notifications = await notificationService.getNotifications(
      userResult.value.id
    );
    expect(notifications.length).toBeGreaterThan(0);
  });

  it("should handle service failures gracefully", async () => {
    // éšœå®³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    await testContainer.stopService("notification-service");

    // ãƒ–ãƒ­ã‚°æŠ•ç¨¿ã¯æˆåŠŸã™ã‚‹ãŒã€é€šçŸ¥ã¯å¤±æ•—ã™ã‚‹
    const result = await blogService.createBlogPost({
      title: "Test Post",
      content: "Test content",
      authorId: "user-123",
      tags: ["test"],
      category: "technology",
    });

    expect(result.isOk()).toBe(true);

    // ã‚µãƒ¼ãƒ“ã‚¹å¾©æ—§å¾Œã€é€šçŸ¥ãŒé€ä¿¡ã•ã‚Œã‚‹
    await testContainer.startService("notification-service");
    await waitForEventProcessing();

    const notifications = await notificationService.getNotifications(
      "user-123"
    );
    expect(notifications.length).toBeGreaterThan(0);
  });
});
```

## ğŸ“Š Week 7-8 è©•ä¾¡åŸºæº–

### ç†è§£åº¦ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

#### ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°ãƒ»CQRS (40%)

- [ ] ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢ã‚’é©åˆ‡ã«å®Ÿè£…ã§ãã‚‹
- [ ] æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ã‚’ç†è§£ã—å®Ÿè£…ã§ãã‚‹
- [ ] Command/Query åˆ†é›¢ã‚’å®Ÿè·µã§ãã‚‹
- [ ] ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°ã‚’è¨­è¨ˆã§ãã‚‹
- [ ] ã‚¤ãƒ™ãƒ³ãƒˆãƒªãƒ—ãƒ¬ã‚¤æ©Ÿèƒ½ã‚’å®Ÿè£…ã§ãã‚‹

#### ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹è¨­è¨ˆ (30%)

- [ ] ã‚µãƒ¼ãƒ“ã‚¹å¢ƒç•Œã‚’é©åˆ‡ã«è¨­è¨ˆã§ãã‚‹
- [ ] ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡ã‚’å®Ÿè£…ã§ãã‚‹
- [ ] éšœå®³è€æ€§ã‚’è€ƒæ…®ã—ãŸè¨­è¨ˆãŒã§ãã‚‹
- [ ] åˆ†æ•£ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç†è§£ã—ã¦ã„ã‚‹
- [ ] API Gateway ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®Ÿè£…ã§ãã‚‹

#### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ (20%)

- [ ] èª­ã¿æ›¸ãåˆ†é›¢ã«ã‚ˆã‚‹æœ€é©åŒ–ã‚’å®Ÿè£…ã§ãã‚‹
- [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã‚’é©åˆ‡ã«è¨­è¨ˆã§ãã‚‹
- [ ] éåŒæœŸå‡¦ç†ã‚’åŠ¹æœçš„ã«æ´»ç”¨ã§ãã‚‹
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–ã‚’å®Ÿè·µã§ãã‚‹

#### ãƒ†ã‚¹ãƒˆãƒ»å“è³ªä¿è¨¼ (10%)

- [ ] çµ±åˆãƒ†ã‚¹ãƒˆã‚’åŒ…æ‹¬çš„ã«å®Ÿè£…ã§ãã‚‹
- [ ] E2E ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ªã‚’è¨­è¨ˆã§ãã‚‹
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’å®Ÿè£…ã§ãã‚‹
- [ ] éšœå®³ãƒ†ã‚¹ãƒˆã‚’è¨­è¨ˆãƒ»å®Ÿè¡Œã§ãã‚‹

### æˆæœç‰©ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] **ãƒ–ãƒ­ã‚°ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ **: å®Œå…¨å‹•ä½œã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ 
- [ ] **ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°å®Ÿè£…**: Event Store + CQRS
- [ ] **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹**: 5 ã¤ã®ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…
- [ ] **çµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ**: åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸
- [ ] **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**: ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãªå®Ÿè£…
- [ ] **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³**: ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ»API ä»•æ§˜

## ğŸ”„ Phase3 å®Œäº†ã¸ã®æº–å‚™

### æœ€çµ‚æˆæœç‰©ã®çµ±åˆ

```typescript
// Phase3ã§ç¿’å¾—ã—ãŸã™ã¹ã¦ã®æŠ€è¡“ã®çµ±åˆä¾‹

// 1. DDD + Value Object (Week 1-2)
const email = Email.create("user@example.com").getValue();
const money = Money.create(100, "USD").getValue();

// 2. Repository + Use Case (Week 3-4)
const createUserUseCase = new CreateUserUseCase(userRepository, domainService);
const result = await createUserUseCase.execute(request);

// 3. Clean Architecture + FP (Week 5-6)
const processedData = flow(
  validateInput,
  transformData,
  applyBusinessRules,
  saveToRepository
)(rawData);

// 4. Event Sourcing + CQRS (Week 7-8)
const blogPost = BlogPost.create(title, content, authorId, tags, category);
await eventStore.saveEvents(blogPost.id, blogPost.getUncommittedEvents(), 0);
```

### Phase4 ã¸ã®ç§»è¡Œæº–å‚™

- [ ] é–‹ç™ºä½“é¨“å‘ä¸Šãƒ„ãƒ¼ãƒ«ã®èª¿æŸ»
- [ ] TypeScript 5.x æ–°æ©Ÿèƒ½ã®å­¦ç¿’
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šãƒ„ãƒ¼ãƒ«ã®æº–å‚™
- [ ] CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æœ€é©åŒ–

---

**ğŸ“Œ é‡è¦**: Week 7-8 ã¯ Phase3 ã®é›†å¤§æˆã¨ã—ã¦ã€ã“ã‚Œã¾ã§å­¦ç¿’ã—ãŸã™ã¹ã¦ã®æŠ€è¡“ã‚’çµ±åˆã—ãŸå®Ÿè·µçš„ãªã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚å˜ãªã‚‹æŠ€è¡“å®Ÿè£…ã ã‘ã§ãªãã€å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§æ±‚ã‚ã‚‰ã‚Œã‚‹å“è³ªãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»ä¿å®ˆæ€§ã‚’æ„è­˜ã—ãŸé–‹ç™ºã‚’è¡Œã„ã¾ã—ã‚‡ã†ã€‚
const event: BlogPostContentUpdatedEvent = {
eventId: crypto.randomUUID(),
aggregateId: this.\_id.toString(),
aggregateType: 'BlogPost',
eventType: 'BlogPostContentUpdated',
eventData: {
title,
content,
updatedAt: new Date()
},
eventVersion: this.version + 1,
occurredAt: new Date()
};

    this.addEvent(event);
    return Result.ok(undefined);

}

apply(event: DomainEvent): void {
switch (event.eventType) {
case 'BlogPostCreated':
this.applyBlogPostCreated(event as BlogPostCreatedEvent);
break;
case 'BlogPostPublished':
this.applyBlogPostPublished(event as BlogPostPublishedEvent);
break;
case 'BlogPostContentUpdated':
this.applyBlogPostContentUpdated(event as BlogPostContentUpdatedEvent);
break;
}
this.version = event.eventVersion;
}

private applyBlogPostCreated(event: BlogPostCreatedEvent): void {
this.\_id = BlogPostId.create(event.aggregateId);
this.\_title = event.eventData.title;
this.\_content = event.eventData.content;
this.\_authorId = UserId.create(event.eventData.authorId);
this.\_tags = event.eventData.tags;
this.\_category = event.eventData.category;
this.\_status = BlogPostStatus.Draft;
this.\_createdAt = event.occurredAt;
this.\_updatedAt = event.occurredAt;
}

private applyBlogPostPublished(event: BlogPostPublishedEvent): void {
this.\_status = BlogPostStatus.Published;
this.\_publishedAt = event.eventData.publishedAt;
this.\_slug = event.eventData.slug;
this.\_updatedAt = event.occurredAt;
}

private applyBlogPostContentUpdated(event: BlogPostContentUpdatedEvent): void {
this.\_title = event.eventData.title;
this.\_content = event.eventData.content;
this.\_updatedAt = event.eventData.updatedAt;
}

private generateSlug(title: string): string {
return title
.toLowerCase()
.replace(/[^a-z0-9\s-]/g, '')
.replace(/\s+/g, '-')
.replace(/-+/g, '-')
.trim('-');
}

// Getters
get id(): BlogPostId { return this.\_id; }
get title(): string { return this.\_title; }
get content(): string { return this.\_content; }
get authorId(): UserId { return this.\_authorId; }
get status(): BlogPostStatus { return this.\_status; }
get tags(): readonly string[] { return [...this._tags]; }
get category(): string { return this.\_category; }
get slug(): string | undefined { return this.\_slug; }
get publishedAt(): Date | undefined { return this.\_publishedAt; }
get createdAt(): Date { return this.\_createdAt; }
get updatedAt(): Date { return this.\_updatedAt; }
}

enum BlogPostStatus {
Draft = 'draft',
Published = 'published',
Archived = 'archived'
}

class BlogPostError extends Error {
constructor(message: string) {
super(message);
this.name = 'BlogPostError';
}
}
