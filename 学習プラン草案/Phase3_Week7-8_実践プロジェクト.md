# Phase 3: Week 7-8 ÂÆüË∑µ„Éó„É≠„Ç∏„Çß„ÇØ„Éà - „Éñ„É≠„Ç∞„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†ÂÆåÂÖ®ÂÆüË£Ö

## üìÖ Â≠¶ÁøíÊúüÈñì„ÉªÁõÆÊ®ô

**ÊúüÈñì**: Week 7-8Ôºà2 ÈÄ±ÈñìÔºâ  
**Á∑èÂ≠¶ÁøíÊôÇÈñì**: 40 ÊôÇÈñìÔºàÈÄ± 10 ÊôÇÈñìÔºâ

### üéØ Week 7-8 Âà∞ÈÅîÁõÆÊ®ô

- [ ] Ë§áÈõë„Å™„Éâ„É°„Ç§„É≥„É¢„Éá„É™„É≥„Ç∞„ÅÆÂÆüË∑µ
- [ ] „Ç§„Éô„É≥„Éà„ÇΩ„Éº„Ç∑„É≥„Ç∞„ÉªCQRS „ÅÆÂÆåÂÖ®ÂÆüË£Ö
- [ ] „Éû„Ç§„ÇØ„É≠„Çµ„Éº„Éì„ÇπË®≠Ë®à„Éë„Çø„Éº„É≥„ÅÆÈÅ©Áî®
- [ ] „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ„Å®„Çπ„Ç±„Éº„É™„É≥„Ç∞ÂØæÂøú
- [ ] Áµ±Âêà„ÉÜ„Çπ„Éà„ÉªE2E „ÉÜ„Çπ„Éà„ÅÆÂÆüË£Ö
- [ ] Êú¨Ê†ºÁöÑ„Å™„Éó„É≠„ÉÄ„ÇØ„Ç∑„Éß„É≥ÂìÅË≥™„Ç∑„Çπ„ÉÜ„É†„ÅÆÊßãÁØâ

## üìñ ÊúÄÁµÇ„Éó„É≠„Ç∏„Çß„ÇØ„Éà: „Éñ„É≠„Ç∞„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†

### üéØ „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊ¶ÇË¶Å

**„Ç∑„Çπ„ÉÜ„É†Âêç**: TypeScript Blog Platform  
**„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**: Event-Driven Microservices with CQRS  
**ÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØ**: TypeScript, Node.js, PostgreSQL, Redis, Docker

### üìã Ê©üËÉΩË¶Å‰ª∂

#### 1. Ë®ò‰∫ãÁÆ°ÁêÜÊ©üËÉΩ

- Ë®ò‰∫ã„ÅÆ‰ΩúÊàê„ÉªÁ∑®ÈõÜ„ÉªÂÖ¨Èñã„Éª‰∏ãÊõ∏„Åç‰øùÂ≠ò
- „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÂØæÂøú
- ÁîªÂÉè„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÉªÁÆ°ÁêÜ
- „Çø„Ç∞„Éª„Ç´„ÉÜ„Ç¥„É™ÁÆ°ÁêÜ
- SEO ÊúÄÈÅ©ÂåñÔºà„É°„Çø„Éá„Éº„ÇøÁÆ°ÁêÜÔºâ

#### 2. „É¶„Éº„Ç∂„ÉºÁÆ°ÁêÜÊ©üËÉΩ

- ËëóËÄÖÁôªÈå≤„ÉªË™çË®º„ÉªË™çÂèØ
- „Éó„É≠„Éï„Ç£„Éº„É´ÁÆ°ÁêÜ
- „É≠„Éº„É´ÁÆ°ÁêÜÔºàÁÆ°ÁêÜËÄÖ„ÉªÁ∑®ÈõÜËÄÖ„ÉªËëóËÄÖ„ÉªË™≠ËÄÖÔºâ
- „Éï„Ç©„É≠„Éº„Éª„Éï„Ç©„É≠„ÉØ„ÉºÊ©üËÉΩ

#### 3. „Ç≥„É°„É≥„Éà„Éª„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥Ê©üËÉΩ

- „Ç≥„É°„É≥„ÉàÊäïÁ®ø„ÉªËøî‰ø°
- „ÅÑ„ÅÑ„Å≠„Éª„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ
- Ë®ò‰∫ãÂÖ±ÊúâÊ©üËÉΩ
- ÈÄöÁü•„Ç∑„Çπ„ÉÜ„É†

#### 4. Ê§úÁ¥¢„ÉªÁô∫Ë¶ãÊ©üËÉΩ

- ÂÖ®ÊñáÊ§úÁ¥¢
- „Çø„Ç∞„Éª„Ç´„ÉÜ„Ç¥„É™Ê§úÁ¥¢
- ‰∫∫Ê∞óË®ò‰∫ã„Éª„Éà„É¨„É≥„ÉâË°®Á§∫
- „É¨„Ç≥„É°„É≥„Éá„Éº„Ç∑„Éß„É≥

## üèóÔ∏è „Ç∑„Çπ„ÉÜ„É†„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ë®≠Ë®à

### „Éû„Ç§„ÇØ„É≠„Çµ„Éº„Éì„ÇπÊßãÊàê

```mermaid
graph TD
    A[API Gateway] --> B[User Service]
    A --> C[Blog Service]
    A --> D[Comment Service]
    A --> E[Search Service]
    A --> F[Notification Service]

    B --> G[User DB]
    C --> H[Blog DB]
    D --> I[Comment DB]
    E --> J[Elasticsearch]
    F --> K[Redis]

    L[Event Bus] --> B
    L --> C
    L --> D
    L --> E
    L --> F

    M[Event Store] --> L

    style A fill:#ff9999
    style L fill:#99ccff
    style M fill:#99ffcc
```

### CQRS + Event Sourcing „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£

```typescript
// Event Sourcing Âü∫Áõ§
interface DomainEvent {
  eventId: string;
  aggregateId: string;
  aggregateType: string;
  eventType: string;
  eventData: any;
  eventVersion: number;
  occurredAt: Date;
  causationId?: string;
  correlationId?: string;
}

interface EventStore {
  saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion: number
  ): Promise<Result<void, EventStoreError>>;

  getEvents(
    aggregateId: string,
    fromVersion?: number
  ): Promise<Result<DomainEvent[], EventStoreError>>;

  getAllEvents(
    fromPosition?: number,
    maxCount?: number
  ): Promise<Result<DomainEvent[], EventStoreError>>;
}

// Event Store ÂÆüË£Ö
class PostgresEventStore implements EventStore {
  constructor(private db: DatabaseConnection) {}

  async saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion: number
  ): Promise<Result<void, EventStoreError>> {
    try {
      await this.db.transaction(async (trx) => {
        // Ê•ΩË¶≥ÁöÑ„É≠„ÉÉ„ÇØ
        const currentVersion = await this.getCurrentVersion(aggregateId, trx);
        if (currentVersion !== expectedVersion) {
          throw new ConcurrencyError(
            `Expected version ${expectedVersion}, but current version is ${currentVersion}`
          );
        }

        // „Ç§„Éô„É≥„Éà‰øùÂ≠ò
        for (const event of events) {
          await trx("events").insert({
            event_id: event.eventId,
            aggregate_id: event.aggregateId,
            aggregate_type: event.aggregateType,
            event_type: event.eventType,
            event_data: JSON.stringify(event.eventData),
            event_version: event.eventVersion,
            occurred_at: event.occurredAt,
            causation_id: event.causationId,
            correlation_id: event.correlationId,
          });
        }
      });

      return Result.ok(undefined);
    } catch (error) {
      return Result.err(
        new EventStoreError(`Failed to save events: ${error.message}`)
      );
    }
  }

  async getEvents(
    aggregateId: string,
    fromVersion: number = 0
  ): Promise<Result<DomainEvent[], EventStoreError>> {
    try {
      const rows = await this.db("events")
        .where("aggregate_id", aggregateId)
        .where("event_version", ">", fromVersion)
        .orderBy("event_version", "asc");

      const events = rows.map((row) => ({
        eventId: row.event_id,
        aggregateId: row.aggregate_id,
        aggregateType: row.aggregate_type,
        eventType: row.event_type,
        eventData: JSON.parse(row.event_data),
        eventVersion: row.event_version,
        occurredAt: row.occurred_at,
        causationId: row.causation_id,
        correlationId: row.correlation_id,
      }));

      return Result.ok(events);
    } catch (error) {
      return Result.err(
        new EventStoreError(`Failed to get events: ${error.message}`)
      );
    }
  }

  private async getCurrentVersion(
    aggregateId: string,
    trx: any
  ): Promise<number> {
    const result = await trx("events")
      .where("aggregate_id", aggregateId)
      .max("event_version as max_version")
      .first();

    return result?.max_version || 0;
  }
}
```

## üìù „Éâ„É°„Ç§„É≥„É¢„Éá„É´ÂÆüË£Ö

### Blog Aggregate

````typescript
// Blog Post Events
interface BlogPostCreatedEvent extends DomainEvent {
  eventType: 'BlogPostCreated';
  eventData: {
    title: string;
    content: string;
    authorId: string;
    tags: string[];
    category: string;
  };
}

interface BlogPostPublishedEvent extends DomainEvent {
  eventType: 'BlogPostPublished';
  eventData: {
    publishedAt: Date;
    slug: string;
  };
}

interface BlogPostContentUpdatedEvent extends DomainEvent {
  eventType: 'BlogPostContentUpdated';
  eventData: {
    title: string;
    content: string;
    updatedAt: Date;
  };
}

// Blog Post Aggregate
class BlogPost extends EventSourcedAggregateRoot {
  private _id: BlogPostId;
  private _title: string;
  private _content: string;
  private _authorId: UserId;
  private _status: BlogPostStatus;
  private _tags: string[];
  private _category: string;
  private _slug?: string;
  private _publishedAt?: Date;
  private _createdAt: Date;
  private _updatedAt: Date;

  private constructor() {
    super();
  }

  static create(
    title: string,
    content: string,
    authorId: UserId,
    tags: string[],
    category: string
  ): Result<BlogPost, BlogPostError> {
    // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if (!title.trim()) {
      return Result.err(new BlogPostError('Title cannot be empty'));
    }
    if (!content.trim()) {
      return Result.err(new BlogPostError('Content cannot be empty'));
    }
    if (tags.length === 0) {
      return Result.err(new BlogPostError('At least one tag is required'));
    }

    const blogPost = new BlogPost();
    const event: BlogPostCreatedEvent = {
      eventId: crypto.randomUUID(),
      aggregateId: BlogPostId.generate().toString(),
      aggregateType: 'BlogPost',
      eventType: 'BlogPostCreated',
      eventData: {
        title,
        content,
        authorId: authorId.toString(),
        tags,
        category
      },
      eventVersion: 1,
      occurredAt: new Date()
    };

    blogPost.addEvent(event);
    return Result.ok(blogPost);
  }

  publish(): Result<void, BlogPostError> {
    if (this._status === BlogPostStatus.Published) {
      return Result.err(new BlogPostError('Blog post is already published'));
    }

    const slug = this.generateSlug(this._title);
    const event: BlogPostPublishedEvent = {
      eventId: crypto.randomUUID(),
      aggregateId: this._id.toString(),
      aggregateType: 'BlogPost',
      eventType: 'BlogPostPublished',
      eventData: {
        publishedAt: new Date(),
        slug
      },
      eventVersion: this.version + 1,
      occurredAt: new Date()
    };

    this.addEvent(event);
    return Result.ok(undefined);
  }

  updateContent(title: string, content: string): Result<void, BlogPostError> {
    if (this._status === BlogPostStatus.Published) {
      return Result.err(new BlogPostError('Cannot update published blog post'));
    }

    if (!title.trim() || !content.trim()) {
      return Result.err(new BlogPostError('Title and content cannot be empty'));
    }

### Comment Aggregate

```typescript
// Comment Events
interface CommentAddedEvent extends DomainEvent {
  eventType: 'CommentAdded';
  eventData: {
    blogPostId: string;
    authorId: string;
    content: string;
    parentCommentId?: string;
  };
}

interface CommentApprovedEvent extends DomainEvent {
  eventType: 'CommentApproved';
  eventData: {
    approvedBy: string;
    approvedAt: Date;
  };
}

// Comment Aggregate
class Comment extends EventSourcedAggregateRoot {
  private _id: CommentId;
  private _blogPostId: BlogPostId;
  private _authorId: UserId;
  private _content: string;
  private _status: CommentStatus;
  private _parentCommentId?: CommentId;
  private _createdAt: Date;
  private _approvedAt?: Date;
  private _approvedBy?: UserId;

  private constructor() {
    super();
  }

  static create(
    blogPostId: BlogPostId,
    authorId: UserId,
    content: string,
    parentCommentId?: CommentId
  ): Result<Comment, CommentError> {
    if (!content.trim()) {
      return Result.err(new CommentError('Comment content cannot be empty'));
    }
    if (content.length > 1000) {
      return Result.err(new CommentError('Comment content too long'));
    }

    const comment = new Comment();
    const event: CommentAddedEvent = {
      eventId: crypto.randomUUID(),
      aggregateId: CommentId.generate().toString(),
      aggregateType: 'Comment',
      eventType: 'CommentAdded',
      eventData: {
        blogPostId: blogPostId.toString(),
        authorId: authorId.toString(),
        content,
        parentCommentId: parentCommentId?.toString()
      },
      eventVersion: 1,
      occurredAt: new Date()
    };

    comment.addEvent(event);
    return Result.ok(comment);
  }

  approve(approvedBy: UserId): Result<void, CommentError> {
    if (this._status === CommentStatus.Approved) {
      return Result.err(new CommentError('Comment is already approved'));
    }

    const event: CommentApprovedEvent = {
      eventId: crypto.randomUUID(),
      aggregateId: this._id.toString(),
      aggregateType: 'Comment',
      eventType: 'CommentApproved',
      eventData: {
        approvedBy: approvedBy.toString(),
        approvedAt: new Date()
      },
      eventVersion: this.version + 1,
      occurredAt: new Date()
    };

    this.addEvent(event);
    return Result.ok(undefined);
  }

  apply(event: DomainEvent): void {
    switch (event.eventType) {
      case 'CommentAdded':
        this.applyCommentAdded(event as CommentAddedEvent);
        break;
      case 'CommentApproved':
        this.applyCommentApproved(event as CommentApprovedEvent);
        break;
    }
    this.version = event.eventVersion;
  }

  private applyCommentAdded(event: CommentAddedEvent): void {
    this._id = CommentId.create(event.aggregateId);
    this._blogPostId = BlogPostId.create(event.eventData.blogPostId);
    this._authorId = UserId.create(event.eventData.authorId);
    this._content = event.eventData.content;
    this._status = CommentStatus.Pending;
    this._parentCommentId = event.eventData.parentCommentId
      ? CommentId.create(event.eventData.parentCommentId)
      : undefined;
    this._createdAt = event.occurredAt;
  }

  private applyCommentApproved(event: CommentApprovedEvent): void {
    this._status = CommentStatus.Approved;
    this._approvedBy = UserId.create(event.eventData.approvedBy);
    this._approvedAt = event.eventData.approvedAt;
  }

  // Getters
  get id(): CommentId { return this._id; }
  get blogPostId(): BlogPostId { return this._blogPostId; }
  get authorId(): UserId { return this._authorId; }
  get content(): string { return this._content; }
  get status(): CommentStatus { return this._status; }
  get parentCommentId(): CommentId | undefined { return this._parentCommentId; }
  get createdAt(): Date { return this._createdAt; }
  get approvedAt(): Date | undefined { return this._approvedAt; }
  get approvedBy(): UserId | undefined { return this._approvedBy; }
}

enum CommentStatus {
  Pending = 'pending',
  Approved = 'approved',
  Rejected = 'rejected'
}

class CommentError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CommentError';
  }
}
````

## üîÑ CQRS ÂÆüË£Ö

### Command Side

```typescript
// Commands
interface CreateBlogPostCommand {
  commandId: string;
  title: string;
  content: string;
  authorId: string;
  tags: string[];
  category: string;
}

interface PublishBlogPostCommand {
  commandId: string;
  blogPostId: string;
  publisherId: string;
}

// Command Handlers
class CreateBlogPostCommandHandler
  implements CommandHandler<CreateBlogPostCommand>
{
  constructor(
    private blogPostRepository: EventSourcedRepository<BlogPost>,
    private eventBus: EventBus,
    private logger: Logger
  ) {}

  async handle(
    command: CreateBlogPostCommand
  ): Promise<Result<void, CommandError>> {
    try {
      const authorId = UserId.create(command.authorId);

      const blogPostResult = BlogPost.create(
        command.title,
        command.content,
        authorId,
        command.tags,
        command.category
      );

      if (blogPostResult.isErr()) {
        return Result.err(new CommandError(blogPostResult.error.message));
      }

      const saveResult = await this.blogPostRepository.save(
        blogPostResult.value
      );
      if (saveResult.isErr()) {
        return Result.err(
          new CommandError(
            `Failed to save blog post: ${saveResult.error.message}`
          )
        );
      }

      // „Ç§„Éô„É≥„ÉàÁô∫Ë°å
      const events = blogPostResult.value.getUncommittedEvents();
      for (const event of events) {
        await this.eventBus.publish(event);
      }

      this.logger.info("Blog post created successfully", {
        commandId: command.commandId,
        blogPostId: blogPostResult.value.id.toString(),
      });

      return Result.ok(undefined);
    } catch (error) {
      this.logger.error("Error handling CreateBlogPostCommand", error);
      return Result.err(new CommandError("An unexpected error occurred"));
    }
  }
}
```

### Query Side

```typescript
// Read Models (Projections)
interface BlogPostProjection {
  id: string;
  title: string;
  content: string;
  excerpt: string;
  authorId: string;
  authorName: string;
  authorAvatar: string;
  status: string;
  tags: string[];
  category: string;
  slug: string;
  publishedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
  commentCount: number;
  likeCount: number;
  viewCount: number;
}

// Queries
interface GetBlogPostQuery {
  queryId: string;
  blogPostId: string;
}

interface GetBlogPostsQuery {
  queryId: string;
  authorId?: string;
  category?: string;
  tags?: string[];
  status?: string;
  page: number;
  pageSize: number;
  sortBy: "createdAt" | "publishedAt" | "viewCount" | "likeCount";
  sortOrder: "asc" | "desc";
}

// Query Handlers
class GetBlogPostQueryHandler
  implements QueryHandler<GetBlogPostQuery, BlogPostProjection>
{
  constructor(
    private blogPostReadRepository: BlogPostReadRepository,
    private logger: Logger
  ) {}

  async handle(
    query: GetBlogPostQuery
  ): Promise<Result<BlogPostProjection, QueryError>> {
    try {
      const blogPost = await this.blogPostReadRepository.findById(
        query.blogPostId
      );

      if (!blogPost) {
        return Result.err(
          new QueryError(`Blog post not found: ${query.blogPostId}`)
        );
      }

      return Result.ok(blogPost);
    } catch (error) {
      this.logger.error("Error handling GetBlogPostQuery", error);
      return Result.err(new QueryError("An unexpected error occurred"));
    }
  }
}
```

## üéØ ÂÆüË∑µÊºîÁøí

### ÊºîÁøí 7-1: „Ç§„Éô„É≥„Éà„ÇΩ„Éº„Ç∑„É≥„Ç∞ÂÆåÂÖ®ÂÆüË£Ö üî•

**ÁõÆÊ®ô**: Event Sourcing + CQRS „ÅÆÂÆåÂÖ®„Å™ÂÆüË£Ö

```typescript
// ‰ª•‰∏ã„ÅÆË¶Å‰ª∂„ÇíÊ∫Ä„Åü„Åô„Ç§„Éô„É≥„Éà„ÇΩ„Éº„Ç∑„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„ÇíÂÆüË£Ö„Åõ„Çà

// Ë¶Å‰ª∂:
// 1. User Aggregate „ÅÆ Event Sourcing ÂÆüË£Ö
// 2. „Ç§„Éô„É≥„Éà„Çπ„Éà„Ç¢„ÅÆÊ•ΩË¶≥ÁöÑ„É≠„ÉÉ„ÇØ
// 3. „Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„ÉàÊ©üËÉΩ
// 4. „Ç§„Éô„É≥„Éà„É™„Éó„É¨„Ç§Ê©üËÉΩ
// 5. „Éó„É≠„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥Êõ¥Êñ∞„ÅÆÂÜ™Á≠âÊÄß

// User Events
interface UserRegisteredEvent extends DomainEvent {
  eventType: "UserRegistered";
  eventData: {
    email: string;
    name: string;
    hashedPassword: string;
  };
}

interface UserProfileUpdatedEvent extends DomainEvent {
  eventType: "UserProfileUpdated";
  eventData: {
    name: string;
    bio: string;
    avatar: string;
  };
}

interface UserFollowedEvent extends DomainEvent {
  eventType: "UserFollowed";
  eventData: {
    followerId: string;
    followedId: string;
  };
}

// User Aggregate
class User extends EventSourcedAggregateRoot {
  private _id: UserId;
  private _email: Email;
  private _name: string;
  private _hashedPassword: string;
  private _bio: string;
  private _avatar: string;
  private _followers: Set<UserId>;
  private _following: Set<UserId>;
  private _createdAt: Date;
  private _updatedAt: Date;

  // ÂÆüË£ÖË¶Å‰ª∂:
  // - ÂÖ®„Å¶„ÅÆ„Ç§„Éô„É≥„Éà„Å´ÂØæ„Åô„Çãapply„É°„ÇΩ„ÉÉ„Éâ
  // - „Éì„Ç∏„Éç„Çπ„É´„Éº„É´„ÅÆÊ§úË®º
  // - „Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„Éà‰ΩúÊàê„ÉªÂæ©ÂÖÉ
  // - „Ç§„Éô„É≥„Éà„É™„Éó„É¨„Ç§Ê©üËÉΩ
}

// „Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„ÉàÊ©üËÉΩ
interface Snapshot {
  aggregateId: string;
  aggregateType: string;
  data: any;
  version: number;
  createdAt: Date;
}

interface SnapshotStore {
  saveSnapshot(snapshot: Snapshot): Promise<Result<void, SnapshotError>>;
  getSnapshot(
    aggregateId: string
  ): Promise<Result<Maybe<Snapshot>, SnapshotError>>;
}

// „Ç§„Éô„É≥„Éà„É™„Éó„É¨„Ç§Ê©üËÉΩ
class EventReplayService {
  constructor(
    private eventStore: EventStore,
    private snapshotStore: SnapshotStore
  ) {}

  async replayEvents<T extends EventSourcedAggregateRoot>(
    aggregateId: string,
    aggregateType: new () => T
  ): Promise<Result<T, ReplayError>> {
    // ÂÆüË£ÖË¶Å‰ª∂:
    // 1. „Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„Éà„Åã„ÇâÂæ©ÂÖÉ
    // 2. „Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„Éà‰ª•Èôç„ÅÆ„Ç§„Éô„É≥„Éà„ÇíÈÅ©Áî®
    // 3. ÁèæÂú®„ÅÆÁä∂ÊÖã„ÇíÂÜçÊßãÁØâ
  }
}
```

### ÊºîÁøí 7-2: „Éû„Ç§„ÇØ„É≠„Çµ„Éº„Éì„ÇπÁµ±Âêà„ÉÜ„Çπ„Éà üî∂

**ÁõÆÊ®ô**: „Éû„Ç§„ÇØ„É≠„Çµ„Éº„Éì„ÇπÈñì„ÅÆÁµ±Âêà„ÉÜ„Çπ„ÉàÂÆüË£Ö

```typescript
// ‰ª•‰∏ã„ÅÆÁµ±Âêà„ÉÜ„Çπ„Éà„Ç∑„Éä„É™„Ç™„ÇíÂÆüË£Ö„Åõ„Çà

// „ÉÜ„Çπ„Éà„Ç∑„Éä„É™„Ç™:
// 1. „É¶„Éº„Ç∂„ÉºÁôªÈå≤ ‚Üí „Éñ„É≠„Ç∞ÊäïÁ®ø‰ΩúÊàê ‚Üí „Ç≥„É°„É≥„ÉàËøΩÂä† ‚Üí ÈÄöÁü•ÈÄÅ‰ø°
// 2. Ë§áÊï∞„Çµ„Éº„Éì„ÇπÈñì„ÅÆ„Ç§„Éô„É≥„ÉàÈÄ£Êê∫„ÉÜ„Çπ„Éà
// 3. ÈöúÂÆ≥ÊôÇ„ÅÆÂæ©Êóß„ÉÜ„Çπ„Éà
// 4. „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà

describe("Blog Platform Integration Tests", () => {
  let testContainer: TestContainer;
  let userService: UserService;
  let blogService: BlogService;
  let commentService: CommentService;
  let notificationService: NotificationService;

  beforeEach(async () => {
    testContainer = await TestContainer.create();
    // „Çµ„Éº„Éì„ÇπÂàùÊúüÂåñ
  });

  it("should handle complete blog workflow", async () => {
    // 1. „É¶„Éº„Ç∂„ÉºÁôªÈå≤
    const userResult = await userService.registerUser({
      email: "test@example.com",
      name: "Test User",
      password: "password123",
    });
    expect(userResult.isOk()).toBe(true);

    // 2. „Éñ„É≠„Ç∞ÊäïÁ®ø‰ΩúÊàê
    const blogPostResult = await blogService.createBlogPost({
      title: "Test Post",
      content: "Test content",
      authorId: userResult.value.id,
      tags: ["test"],
      category: "technology",
    });
    expect(blogPostResult.isOk()).toBe(true);

    // 3. „Éñ„É≠„Ç∞ÊäïÁ®øÂÖ¨Èñã
    const publishResult = await blogService.publishBlogPost({
      blogPostId: blogPostResult.value.id,
      publisherId: userResult.value.id,
    });
    expect(publishResult.isOk()).toBe(true);

    // 4. „Ç≥„É°„É≥„ÉàËøΩÂä†
    const commentResult = await commentService.addComment({
      blogPostId: blogPostResult.value.id,
      authorId: userResult.value.id,
      content: "Great post!",
    });
    expect(commentResult.isOk()).toBe(true);

    // 5. ÈÄöÁü•Á¢∫Ë™ç
    await waitForEventProcessing();
    const notifications = await notificationService.getNotifications(
      userResult.value.id
    );
    expect(notifications.length).toBeGreaterThan(0);
  });

  it("should handle service failures gracefully", async () => {
    // ÈöúÂÆ≥„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
    await testContainer.stopService("notification-service");

    // „Éñ„É≠„Ç∞ÊäïÁ®ø„ÅØÊàêÂäü„Åô„Çã„Åå„ÄÅÈÄöÁü•„ÅØÂ§±Êïó„Åô„Çã
    const result = await blogService.createBlogPost({
      title: "Test Post",
      content: "Test content",
      authorId: "user-123",
      tags: ["test"],
      category: "technology",
    });

    expect(result.isOk()).toBe(true);

    // „Çµ„Éº„Éì„ÇπÂæ©ÊóßÂæå„ÄÅÈÄöÁü•„ÅåÈÄÅ‰ø°„Åï„Çå„Çã
    await testContainer.startService("notification-service");
    await waitForEventProcessing();

    const notifications = await notificationService.getNotifications(
      "user-123"
    );
    expect(notifications.length).toBeGreaterThan(0);
  });
});
```

## üìä Week 7-8 Ë©ï‰æ°Âü∫Ê∫ñ

### ÁêÜËß£Â∫¶„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà

#### „Ç§„Éô„É≥„Éà„ÇΩ„Éº„Ç∑„É≥„Ç∞„ÉªCQRS (40%)

- [ ] „Ç§„Éô„É≥„Éà„Çπ„Éà„Ç¢„ÇíÈÅ©Âàá„Å´ÂÆüË£Ö„Åß„Åç„Çã
- [ ] Ê•ΩË¶≥ÁöÑ„É≠„ÉÉ„ÇØ„ÇíÁêÜËß£„ÅóÂÆüË£Ö„Åß„Åç„Çã
- [ ] Command/Query ÂàÜÈõ¢„ÇíÂÆüË∑µ„Åß„Åç„Çã
- [ ] „Éó„É≠„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥Êõ¥Êñ∞„ÇíË®≠Ë®à„Åß„Åç„Çã
- [ ] „Ç§„Éô„É≥„Éà„É™„Éó„É¨„Ç§Ê©üËÉΩ„ÇíÂÆüË£Ö„Åß„Åç„Çã

#### „Éû„Ç§„ÇØ„É≠„Çµ„Éº„Éì„ÇπË®≠Ë®à (30%)

- [ ] „Çµ„Éº„Éì„ÇπÂ¢ÉÁïå„ÇíÈÅ©Âàá„Å´Ë®≠Ë®à„Åß„Åç„Çã
- [ ] „Çµ„Éº„Éì„ÇπÈñìÈÄö‰ø°„ÇíÂÆüË£Ö„Åß„Åç„Çã
- [ ] ÈöúÂÆ≥ËÄêÊÄß„ÇíËÄÉÊÖÆ„Åó„ÅüË®≠Ë®à„Åå„Åß„Åç„Çã
- [ ] ÂàÜÊï£„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÇíÁêÜËß£„Åó„Å¶„ÅÑ„Çã
- [ ] API Gateway „Éë„Çø„Éº„É≥„ÇíÂÆüË£Ö„Åß„Åç„Çã

#### „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Éª„Çπ„Ç±„Éº„É©„Éì„É™„ÉÜ„Ç£ (20%)

- [ ] Ë™≠„ÅøÊõ∏„ÅçÂàÜÈõ¢„Å´„Çà„ÇãÊúÄÈÅ©Âåñ„ÇíÂÆüË£Ö„Åß„Åç„Çã
- [ ] „Ç≠„É£„ÉÉ„Ç∑„É•Êà¶Áï•„ÇíÈÅ©Âàá„Å´Ë®≠Ë®à„Åß„Åç„Çã
- [ ] ÈùûÂêåÊúüÂá¶ÁêÜ„ÇíÂäπÊûúÁöÑ„Å´Ê¥ªÁî®„Åß„Åç„Çã
- [ ] „Éá„Éº„Çø„Éô„Éº„ÇπÊúÄÈÅ©Âåñ„ÇíÂÆüË∑µ„Åß„Åç„Çã

#### „ÉÜ„Çπ„Éà„ÉªÂìÅË≥™‰øùË®º (10%)

- [ ] Áµ±Âêà„ÉÜ„Çπ„Éà„ÇíÂåÖÊã¨ÁöÑ„Å´ÂÆüË£Ö„Åß„Åç„Çã
- [ ] E2E „ÉÜ„Çπ„Éà„Ç∑„Éä„É™„Ç™„ÇíË®≠Ë®à„Åß„Åç„Çã
- [ ] „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà„ÇíÂÆüË£Ö„Åß„Åç„Çã
- [ ] ÈöúÂÆ≥„ÉÜ„Çπ„Éà„ÇíË®≠Ë®à„ÉªÂÆüË°å„Åß„Åç„Çã

### ÊàêÊûúÁâ©„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà

- [ ] **„Éñ„É≠„Ç∞„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†**: ÂÆåÂÖ®Âãï‰Ωú„Åô„Çã„Ç∑„Çπ„ÉÜ„É†
- [ ] **„Ç§„Éô„É≥„Éà„ÇΩ„Éº„Ç∑„É≥„Ç∞ÂÆüË£Ö**: Event Store + CQRS
- [ ] **„Éû„Ç§„ÇØ„É≠„Çµ„Éº„Éì„Çπ**: 5 „Å§„ÅÆ„Çµ„Éº„Éì„ÇπÂÆüË£Ö
- [ ] **Áµ±Âêà„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà**: ÂåÖÊã¨ÁöÑ„Å™„ÉÜ„Çπ„Éà„Ç´„Éê„É¨„ÉÉ„Ç∏
- [ ] **„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ**: „Çπ„Ç±„Éº„É©„Éñ„É´„Å™ÂÆüË£Ö
- [ ] **„Éâ„Ç≠„É•„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥**: „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÉªAPI ‰ªïÊßò

## üîÑ Phase3 ÂÆå‰∫Ü„Å∏„ÅÆÊ∫ñÂÇô

### ÊúÄÁµÇÊàêÊûúÁâ©„ÅÆÁµ±Âêà

```typescript
// Phase3„ÅßÁøíÂæó„Åó„Åü„Åô„Åπ„Å¶„ÅÆÊäÄË°ì„ÅÆÁµ±Âêà‰æã

// 1. DDD + Value Object (Week 1-2)
const email = Email.create("user@example.com").getValue();
const money = Money.create(100, "USD").getValue();

// 2. Repository + Use Case (Week 3-4)
const createUserUseCase = new CreateUserUseCase(userRepository, domainService);
const result = await createUserUseCase.execute(request);

// 3. Clean Architecture + FP (Week 5-6)
const processedData = flow(
  validateInput,
  transformData,
  applyBusinessRules,
  saveToRepository
)(rawData);

// 4. Event Sourcing + CQRS (Week 7-8)
const blogPost = BlogPost.create(title, content, authorId, tags, category);
await eventStore.saveEvents(blogPost.id, blogPost.getUncommittedEvents(), 0);
```

### Phase4 „Å∏„ÅÆÁßªË°åÊ∫ñÂÇô

- [ ] ÈñãÁô∫‰ΩìÈ®ìÂêë‰∏ä„ÉÑ„Éº„É´„ÅÆË™øÊüª
- [ ] TypeScript 5.x Êñ∞Ê©üËÉΩ„ÅÆÂ≠¶Áøí
- [ ] „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊ∏¨ÂÆö„ÉÑ„Éº„É´„ÅÆÊ∫ñÂÇô
- [ ] CI/CD „Éë„Ç§„Éó„É©„Ç§„É≥„ÅÆÊúÄÈÅ©Âåñ

---

**üìå ÈáçË¶Å**: Week 7-8 „ÅØ Phase3 „ÅÆÈõÜÂ§ßÊàê„Å®„Åó„Å¶„ÄÅ„Åì„Çå„Åæ„ÅßÂ≠¶Áøí„Åó„Åü„Åô„Åπ„Å¶„ÅÆÊäÄË°ì„ÇíÁµ±Âêà„Åó„ÅüÂÆüË∑µÁöÑ„Å™„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åó„Åæ„Åô„ÄÇÂçò„Å™„ÇãÊäÄË°ìÂÆüË£Ö„Å†„Åë„Åß„Å™„Åè„ÄÅÂÆüÈöõ„ÅÆ„Éó„É≠„ÉÄ„ÇØ„Ç∑„Éß„É≥Áí∞Â¢É„ÅßÊ±Ç„ÇÅ„Çâ„Çå„ÇãÂìÅË≥™„Éª„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Éª‰øùÂÆàÊÄß„ÇíÊÑèË≠ò„Åó„ÅüÈñãÁô∫„ÇíË°å„ÅÑ„Åæ„Åó„Çá„ÅÜ„ÄÇ
const event: BlogPostContentUpdatedEvent = {
eventId: crypto.randomUUID(),
aggregateId: this.\_id.toString(),
aggregateType: 'BlogPost',
eventType: 'BlogPostContentUpdated',
eventData: {
title,
content,
updatedAt: new Date()
},
eventVersion: this.version + 1,
occurredAt: new Date()
};

    this.addEvent(event);
    return Result.ok(undefined);

}

apply(event: DomainEvent): void {
switch (event.eventType) {
case 'BlogPostCreated':
this.applyBlogPostCreated(event as BlogPostCreatedEvent);
break;
case 'BlogPostPublished':
this.applyBlogPostPublished(event as BlogPostPublishedEvent);
break;
case 'BlogPostContentUpdated':
this.applyBlogPostContentUpdated(event as BlogPostContentUpdatedEvent);
break;
}
this.version = event.eventVersion;
}

private applyBlogPostCreated(event: BlogPostCreatedEvent): void {
this.\_id = BlogPostId.create(event.aggregateId);
this.\_title = event.eventData.title;
this.\_content = event.eventData.content;
this.\_authorId = UserId.create(event.eventData.authorId);
this.\_tags = event.eventData.tags;
this.\_category = event.eventData.category;
this.\_status = BlogPostStatus.Draft;
this.\_createdAt = event.occurredAt;
this.\_updatedAt = event.occurredAt;
}

private applyBlogPostPublished(event: BlogPostPublishedEvent): void {
this.\_status = BlogPostStatus.Published;
this.\_publishedAt = event.eventData.publishedAt;
this.\_slug = event.eventData.slug;
this.\_updatedAt = event.occurredAt;
}

private applyBlogPostContentUpdated(event: BlogPostContentUpdatedEvent): void {
this.\_title = event.eventData.title;
this.\_content = event.eventData.content;
this.\_updatedAt = event.eventData.updatedAt;
}

private generateSlug(title: string): string {
return title
.toLowerCase()
.replace(/[^a-z0-9\s-]/g, '')
.replace(/\s+/g, '-')
.replace(/-+/g, '-')
.trim('-');
}

// Getters
get id(): BlogPostId { return this.\_id; }
get title(): string { return this.\_title; }
get content(): string { return this.\_content; }
get authorId(): UserId { return this.\_authorId; }
get status(): BlogPostStatus { return this.\_status; }
get tags(): readonly string[] { return [...this._tags]; }
get category(): string { return this.\_category; }
get slug(): string | undefined { return this.\_slug; }
get publishedAt(): Date | undefined { return this.\_publishedAt; }
get createdAt(): Date { return this.\_createdAt; }
get updatedAt(): Date { return this.\_updatedAt; }
}

enum BlogPostStatus {
Draft = 'draft',
Published = 'published',
Archived = 'archived'
}

class BlogPostError extends Error {
constructor(message: string) {
super(message);
this.name = 'BlogPostError';
}
}
