# Week 11: ツール開発入門

## 📅 学習期間・目標

**期間**: Week 11（7日間）  
**総学習時間**: 12時間（平日1.5時間、週末3時間）  
**学習スタイル**: 理論30% + 実践コード50% + 演習20%

### 🎯 Week 11 到達目標

- [ ] ESLint ルールの設定とカスタマイズ
- [ ] 簡単な開発ツールの作成
- [ ] TypeScript Compiler API の基礎理解
- [ ] 自動化スクリプトの実装
- [ ] 開発効率向上ツールの構築

## 📚 理論学習内容

### Day 1-2: ESLint設定とカスタマイズ

#### 🔍 TypeScript用ESLint設定

```typescript
// .eslintrc.js
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module',
    project: './tsconfig.json',
  },
  plugins: ['@typescript-eslint'],
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    '@typescript-eslint/recommended-requiring-type-checking',
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/explicit-function-return-type': 'error',
    '@typescript-eslint/naming-convention': [
      'error',
      {
        selector: 'interface',
        format: ['PascalCase'],
      },
      {
        selector: 'typeAlias',
        format: ['PascalCase'],
      },
    ],
  },
};
```

#### 🎯 カスタムESLintルールの作成

```typescript
// eslint-rules/no-any-type.js
module.exports = {
  meta: {
    type: 'problem',
    docs: {
      description: 'Disallow usage of any type',
      category: 'TypeScript',
      recommended: true,
    },
    messages: {
      noAnyType: 'Using "any" type is not allowed. Please use a more specific type.',
    },
  },
  
  create(context) {
    return {
      TSAnyKeyword(node) {
        context.report({
          node,
          messageId: 'noAnyType',
        });
      },
    };
  },
};
```

### Day 3-4: 開発ツールの作成

#### 🔧 型定義生成ツール

```typescript
// tools/type-generator.ts
import * as fs from 'fs';
import * as path from 'path';

interface ApiEndpoint {
  method: string;
  path: string;
  requestBody?: any;
  responseBody: any;
  description?: string;
}

class TypeScriptGenerator {
  private output: string[] = [];

  generateTypes(spec: { endpoints: Record<string, ApiEndpoint> }): string {
    this.output = [];
    
    // ヘッダーコメント
    this.output.push('// Generated TypeScript types');
    this.output.push('// Do not edit this file manually');
    this.output.push('');

    // API型の生成
    this.output.push('export namespace API {');
    
    for (const [endpointName, endpoint] of Object.entries(spec.endpoints)) {
      this.generateEndpointTypes(endpointName, endpoint);
    }
    
    this.output.push('}');

    return this.output.join('\n');
  }

  private generateEndpointTypes(name: string, endpoint: ApiEndpoint): void {
    const capitalizedName = this.capitalize(name);
    
    this.output.push(`  export namespace ${capitalizedName} {`);
    
    if (endpoint.requestBody) {
      this.output.push('    export interface Request {');
      this.generateObjectProperties(endpoint.requestBody, 6);
      this.output.push('    }');
    }

    this.output.push('    export interface Response {');
    this.generateObjectProperties(endpoint.responseBody, 6);
    this.output.push('    }');
    this.output.push('  }');
  }

  private generateObjectProperties(obj: any, indent: number): void {
    const spaces = ' '.repeat(indent);
    for (const [propName, propSpec] of Object.entries(obj.properties || {})) {
      const type = this.getTypeString(propSpec);
      this.output.push(`${spaces}${propName}: ${type};`);
    }
  }

  private getTypeString(spec: any): string {
    switch (spec.type) {
      case 'string': return 'string';
      case 'number': return 'number';
      case 'boolean': return 'boolean';
      case 'array': return `${this.getTypeString(spec.items)}[]`;
      default: return 'unknown';
    }
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}

// 使用例
const generator = new TypeScriptGenerator();
const spec = {
  endpoints: {
    getUser: {
      method: 'GET',
      path: '/users/:id',
      responseBody: {
        properties: {
          id: { type: 'number' },
          name: { type: 'string' },
          email: { type: 'string' }
        }
      }
    }
  }
};

const types = generator.generateTypes(spec);
console.log(types);
```

### Day 5-7: TypeScript Compiler API

#### 🔧 AST操作の基礎

```typescript
// tools/ast-transformer.ts
import * as ts from 'typescript';

class ASTTransformer {
  transformFile(fileName: string): string {
    const program = ts.createProgram([fileName], {});
    const sourceFile = program.getSourceFile(fileName);
    
    if (!sourceFile) {
      throw new Error(`File not found: ${fileName}`);
    }

    const transformer: ts.TransformerFactory<ts.SourceFile> = (context) => {
      return (sourceFile) => {
        const visitor = (node: ts.Node): ts.Node => {
          // console.log文を削除
          if (ts.isCallExpression(node) && 
              ts.isPropertyAccessExpression(node.expression) &&
              ts.isIdentifier(node.expression.expression) &&
              node.expression.expression.text === 'console') {
            return ts.factory.createEmptyStatement();
          }
          
          return ts.visitEachChild(node, visitor, context);
        };
        
        return ts.visitNode(sourceFile, visitor);
      };
    };

    const result = ts.transform(sourceFile, [transformer]);
    const printer = ts.createPrinter();
    
    return printer.printFile(result.transformed[0]);
  }

  analyzeFile(fileName: string): {
    functions: string[];
    classes: string[];
    interfaces: string[];
  } {
    const program = ts.createProgram([fileName], {});
    const sourceFile = program.getSourceFile(fileName);
    
    if (!sourceFile) {
      throw new Error(`File not found: ${fileName}`);
    }

    const analysis = {
      functions: [] as string[],
      classes: [] as string[],
      interfaces: [] as string[],
    };

    const visit = (node: ts.Node): void => {
      if (ts.isFunctionDeclaration(node) && node.name) {
        analysis.functions.push(node.name.text);
      } else if (ts.isClassDeclaration(node) && node.name) {
        analysis.classes.push(node.name.text);
      } else if (ts.isInterfaceDeclaration(node)) {
        analysis.interfaces.push(node.name.text);
      }
      
      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
    return analysis;
  }
}

// 使用例
const transformer = new ASTTransformer();

// ファイル分析
const analysis = transformer.analyzeFile('./src/example.ts');
console.log('Functions:', analysis.functions);
console.log('Classes:', analysis.classes);
console.log('Interfaces:', analysis.interfaces);

// ファイル変換
const transformed = transformer.transformFile('./src/example.ts');
console.log('Transformed code:', transformed);
```

#### 🎯 自動化スクリプト

```typescript
// tools/project-automation.ts
import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

class ProjectAutomation {
  // プロジェクト初期化
  initProject(projectName: string, template: 'library' | 'api' | 'frontend'): void {
    const projectPath = path.join(process.cwd(), projectName);
    
    if (fs.existsSync(projectPath)) {
      throw new Error(`Project ${projectName} already exists`);
    }

    fs.mkdirSync(projectPath, { recursive: true });
    process.chdir(projectPath);

    // package.json作成
    const packageJson = {
      name: projectName,
      version: '1.0.0',
      description: '',
      main: 'dist/index.js',
      types: 'dist/index.d.ts',
      scripts: this.getScripts(template),
      devDependencies: this.getDevDependencies(template),
      dependencies: this.getDependencies(template),
    };

    fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));

    // TypeScript設定
    this.createTsConfig(template);
    
    // ディレクトリ構造作成
    this.createDirectoryStructure(template);
    
    // 初期ファイル作成
    this.createInitialFiles(template);

    console.log(`✅ Project ${projectName} created successfully!`);
    console.log('Next steps:');
    console.log(`  cd ${projectName}`);
    console.log('  npm install');
    console.log('  npm run build');
  }

  private getScripts(template: string): Record<string, string> {
    const baseScripts = {
      build: 'tsc',
      'build:watch': 'tsc --watch',
      test: 'jest',
      'test:watch': 'jest --watch',
      lint: 'eslint src/**/*.ts',
      'lint:fix': 'eslint src/**/*.ts --fix',
    };

    if (template === 'api') {
      return {
        ...baseScripts,
        start: 'node dist/server.js',
        dev: 'ts-node src/server.ts',
      };
    }

    return baseScripts;
  }

  private getDevDependencies(template: string): Record<string, string> {
    const base = {
      'typescript': '^5.0.0',
      '@types/node': '^20.0.0',
      'jest': '^29.0.0',
      'ts-jest': '^29.0.0',
      '@types/jest': '^29.0.0',
      'eslint': '^8.0.0',
      '@typescript-eslint/parser': '^6.0.0',
      '@typescript-eslint/eslint-plugin': '^6.0.0',
    };

    if (template === 'api') {
      return {
        ...base,
        'ts-node': '^10.0.0',
        'nodemon': '^3.0.0',
        '@types/express': '^4.17.0',
        'supertest': '^6.0.0',
        '@types/supertest': '^2.0.0',
      };
    }

    return base;
  }

  private getDependencies(template: string): Record<string, string> {
    if (template === 'api') {
      return {
        'express': '^4.18.0',
        'cors': '^2.8.0',
        'helmet': '^7.0.0',
      };
    }

    return {};
  }

  private createTsConfig(template: string): void {
    const tsConfig = {
      compilerOptions: {
        target: 'ES2020',
        module: 'commonjs',
        lib: ['ES2020'],
        outDir: './dist',
        rootDir: './src',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        declaration: true,
        declarationMap: true,
        sourceMap: true,
      },
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist', 'tests'],
    };

    fs.writeFileSync('tsconfig.json', JSON.stringify(tsConfig, null, 2));
  }

  private createDirectoryStructure(template: string): void {
    const dirs = ['src', 'tests', 'dist'];
    
    if (template === 'api') {
      dirs.push('src/routes', 'src/controllers', 'src/middleware', 'src/types');
    } else if (template === 'library') {
      dirs.push('src/lib', 'src/types');
    }

    dirs.forEach(dir => {
      fs.mkdirSync(dir, { recursive: true });
    });
  }

  private createInitialFiles(template: string): void {
    if (template === 'library') {
      fs.writeFileSync('src/index.ts', `// Library entry point
export * from './lib';
`);
      fs.writeFileSync('src/lib/index.ts', `// Library implementation
export function hello(name: string): string {
  return \`Hello, \${name}!\`;
}
`);
    } else if (template === 'api') {
      fs.writeFileSync('src/server.ts', `import express from 'express';

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
  res.json({ message: 'Hello, TypeScript API!' });
});

app.listen(PORT, () => {
  console.log(\`Server running on port \${PORT}\`);
});
`);
    }

    // README作成
    fs.writeFileSync('README.md', `# ${path.basename(process.cwd())}

## Installation

\`\`\`bash
npm install
\`\`\`

## Development

\`\`\`bash
npm run build
npm test
\`\`\`
`);

    // .gitignore作成
    fs.writeFileSync('.gitignore', `node_modules/
dist/
coverage/
*.log
.env
.DS_Store
`);
  }

  // コード品質チェック
  checkCodeQuality(directory: string = './src'): void {
    console.log('🔍 Running code quality checks...');
    
    try {
      // TypeScript コンパイルチェック
      execSync('npx tsc --noEmit', { stdio: 'inherit' });
      console.log('✅ TypeScript compilation check passed');
      
      // ESLint チェック
      execSync(`npx eslint ${directory}/**/*.ts`, { stdio: 'inherit' });
      console.log('✅ ESLint check passed');
      
      // テスト実行
      execSync('npm test', { stdio: 'inherit' });
      console.log('✅ Tests passed');
      
    } catch (error) {
      console.error('❌ Code quality check failed');
      process.exit(1);
    }
  }

  // 依存関係更新
  updateDependencies(): void {
    console.log('📦 Updating dependencies...');
    
    try {
      execSync('npm update', { stdio: 'inherit' });
      execSync('npm audit fix', { stdio: 'inherit' });
      console.log('✅ Dependencies updated successfully');
    } catch (error) {
      console.error('❌ Failed to update dependencies');
    }
  }
}

// CLI実行
if (require.main === module) {
  const automation = new ProjectAutomation();
  const [command, ...args] = process.argv.slice(2);

  switch (command) {
    case 'init':
      const [projectName, template = 'library'] = args;
      automation.initProject(projectName, template as any);
      break;
    case 'check':
      automation.checkCodeQuality();
      break;
    case 'update':
      automation.updateDependencies();
      break;
    default:
      console.log('Usage:');
      console.log('  init <project-name> [template]  - Initialize new project');
      console.log('  check                           - Run code quality checks');
      console.log('  update                          - Update dependencies');
  }
}

export { ProjectAutomation };
```

## 📊 Week 11 評価基準

### 理解度チェックリスト

#### ESLint設定 (25%)
- [ ] TypeScript用ESLint設定を理解している
- [ ] カスタムルールを作成できる
- [ ] プロジェクトに適した設定ができる
- [ ] コード品質の自動チェックを実装できる

#### 開発ツール作成 (30%)
- [ ] 型定義生成ツールを作成できる
- [ ] コード分析ツールを実装できる
- [ ] 自動化スクリプトを作成できる
- [ ] 実用的なツールを設計できる

#### Compiler API (25%)
- [ ] TypeScript Compiler APIの基礎を理解している
- [ ] AST操作を実装できる
- [ ] コード変換を実装できる
- [ ] 静的解析ツールを作成できる

#### 自動化・効率化 (20%)
- [ ] プロジェクト初期化を自動化できる
- [ ] 品質チェックを自動化できる
- [ ] 開発ワークフローを改善できる
- [ ] 継続的な改善を実装できる

### 成果物チェックリスト

- [ ] **ESLint設定**: プロジェクト用カスタム設定
- [ ] **型定義生成ツール**: API仕様から型生成
- [ ] **コード品質チェッカー**: 静的解析ツール
- [ ] **プロジェクト自動化ツール**: 初期化・管理ツール

## 🔄 Week 12 への準備

### 次週学習内容の予習

```typescript
// Week 12で学習するポートフォリオ作成の基礎概念
// 以下のコードを読んで理解しておくこと

// 1. プロジェクト統合
interface ProjectShowcase {
  title: string;
  description: string;
  technologies: string[];
  demoUrl?: string;
  sourceUrl: string;
}

// 2. ドキュメント生成
interface Documentation {
  overview: string;
  installation: string;
  usage: string;
  api: string;
}
```

---

**📌 重要**: Week 11はTypeScriptを使った開発ツール作成の基礎を学ぶ重要な週です。これらのスキルにより、開発効率を大幅に向上させるツールが作成できるようになります。

**🌟 次週は、学習の総仕上げとしてポートフォリオを完成させます！**